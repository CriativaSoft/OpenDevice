/*
	ExtendJS 0.2.3
	More info at http://extendjs.org

	Copyright (c) 2013+ ChrisBenjaminsen.com

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
(function(global){
    "use strict";
	//Helper method for creating an super copied object clone
	function initialize(method){
		//Recursivly execute parent methods.
		if(method.parent instanceof Function){
			initialize.apply(this,[method.parent]);
			this.super = cloneCopy(this,
				superCopy(this,this.constructor)
			);
		}
		method.apply(this, arguments);
	}

	//Helper method which allows for super referances.
	function cloneCopy(from, to){
		for(var x in from){
			if(	
				x !== "super" && //Never clone the super referance
				from[x] instanceof Function && //Only overwrite functions
				!(from[x].prototype instanceof Class) //Never overwrite referances to classes
			){
				//Never create circular super referances.
				to[x] = from[x].super || superCopy(from, from[x]);
			}
		}
		return to;
	}

	function superCopy(scope, method){
		var scopeSuper = scope.super;
		return method.super = function(){
			var oldScope = scope.super;
			scope.super = scopeSuper;
			var methodReturn = method.apply(scope, arguments);
			scope.super = oldScope;
			return methodReturn;
		}
	}

	//Create Class object
	global.Class = function(){};
	global.Class.extend = function ext(to){
		function child(){
			//Prevent the prototype scope set executing the constructor.
			if(initialize !== arguments[0]){
				//Create inhereted object
				initialize.apply(this,[to]);
				//Setup scope for class instance method calls
				cloneCopy(this,this);
				if(this.initializer instanceof Function)
					this.initializer.apply(this);
				this.constructor.apply(this,arguments);
			}
		}

		//Set prototype and constructor enabeling propper type checking.
		child.prototype = new this(initialize);
		child.prototype.constructor = child;

		//Return expected result from toString
		child.toString = function(){
			return to.toString()
		}

		//Allow the child to be extended.
		child.extend = function(target){
			//Create parent referance and inherentence path.
			target.parent = to;
			return ext.apply(child,arguments);
		}
	
		return child
	}
	//Bootstrap Class by inheriting itself with empty constructor.
	global.Class = global.Class.extend(function() {
        this.constructor=function(){}
    });
})(this)
/* ---------- */'use strict';

/*
 * ******************************************************************************
 *  Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

/** @namespace */
var od = od || {};

od.view = od.view || {};

od.view.availableTypes = {
    LINE_CHART:"Line Chart",
    PIE_CHART:"Pie Chart",
    GAUGE_CHART:"Gauge"
};

od.view.dashTypes = {};

/**
 * Responsable to render charts and view on dashboard
 * @date 25/04/2015
 * @class DashItemView
 */
od.view.DashItemView = Class.extend(function() {

    // Public
    // ======================

    this.el; // reference to div.dash-body
    this.initialized = false;
    this.configMode = false;
    this.resizing = false;
    this.data = [];

    // ==========================================================================
    // Public
    // ==========================================================================


    this.constructor = function (data) {
        this.setModel(data);
    }

    this.render = function ($el) {

    };

    this.onResize = function (force) {
    };

    this.onStartResize = function () {
    };


    this.destroy = function () {
        $(this.el).remove();
    };

    this.update = function (data) {

        var reloadDataset = false;  // some changes in Model, need reload chart

        if(this.model.error) reloadDataset = true;

        if(data.type != this.model.type) reloadDataset = true;

        if(data.realtime != this.model.realtime) reloadDataset = true;

        if(data.monitoredDevices.length != this.model.monitoredDevices.length){
            reloadDataset = true;
        }

        this.setModel(data);

        return reloadDataset;
    };

    this.setModel = function (data) {

        if (typeof  data.layout == 'string') data.layout = JSON.parse(data.layout); // convert from String to Array

        // Copy all Atributes
        for (var attrname in data) {
            if (attrname.lastIndexOf("$", 0) == -1) { // ignore angular.js trash
                this[attrname] = data[attrname];
            } else {
                data[attrname] = null; // ignore angular.js trash
            }
        }

        this["layout"] = $.extend({}, data.layout); // make copy (not reference) to detect changes.

        this.model = data;
    };



    // ==========================================================================
    // Private
    // ==========================================================================



});

// =====================================================================================================================
// Static Functions
// =====================================================================================================================
od.view.DashItemView.isCompatibleChart = function(type){
    if(type == 'LINE_CHART' || type == 'GAUGE_CHART' || type == 'PIE_CHART' || type == 'AREA_CHART'){
        return true;
    }
    return false;
};

od.view.DashItemView.requireAggregation = function(type){
    if(type == 'DYNAMIC_VALUE' || type == 'GAUGE_CHART' || type == 'PIE_CHART'){
        return true;
    }
    return false;
};/* ---------- */'use strict';
/*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */


// Register new Type
$.extend(od.view.dashTypes, {
    LINE_CHART: {
        id: "LINE_CHART",
        name: "Line Chart",
        klass: "od.view.ChartItemView",
        multipleDevices: true,
        allowSensor : true,
        allowDevice : false,
        deviceTypes: [od.DeviceType.ANALOG],
        fields: [
            // Name, required
            ["realtime", false],
            ["period", true],
        ]
    },
    AREA_CHART: { // Use same chart/code of LINE
        id: "AREA_CHART",
        name: "Area Chart",
        klass: "od.view.ChartItemView",
        multipleDevices: false,
        allowSensor : true,
        allowDevice : true,
        deviceTypes: [od.DeviceType.DIGITAL],
        fields: [
            // Name, required
            ["realtime", false],
            ["period", true],
        ]
    },
    PIE_CHART: {
        id: "PIE_CHART",
        name: "Pie Chart",
        klass: "od.view.ChartItemView",
        multipleDevices: true,
        allowSensor : true,
        allowDevice : false,
        deviceTypes: [od.DeviceType.ANALOG],
        fields: [
            // Name, required
            ["aggregation", true],// "(!realtime)"
            ["realtime", false],
            ["period", true],
        ]

    },
    GAUGE_CHART: {
        id: "GAUGE_CHART",
        name: "Gauge",
        klass: "od.view.ChartItemView",
        multipleDevices: true,
        allowSensor : true,
        allowDevice : false,
        deviceTypes: [od.DeviceType.ANALOG],
        fields: [
            // Name, required
            ["subtype", true, null],
            ["aggregation", true],// "(!realtime)"
            ["realtime", false],
            ["period", true],
        ]

    }
});


/**
 * Responsable to render charts and view on dashboard
 * @date 25/04/2015
 * @class DashItemView
 */
od.view.ChartItemView = od.view.DashItemView.extend(function() {

    // Private
    // ======================

    var chart;
    var realtimeListeners = [];

    // Public
    // ======================

    this.el; // reference to div.dash-body
    this.initialized = false;
    this.configMode = false;
    this.resizing = false;
    this.data = [];


    // ==========================================================================
    // Public
    // ==========================================================================

    this.render = function ($el) {


        this.el = $el;

        if (this.model.realtime) {

            for (var i = 0; i < this.model.monitoredDevices.length; i++) {
                var device = ODev.get(this.model.monitoredDevices[i]);
                if(device){
                    var listener = device.onChange(updateRealtimeData, this);
                    realtimeListeners.push(listener);
                }else{
                    this.model.error = true;
                    this.model.errorMessage = "Device Not Found";
                    console.error("Chart Error ("+this.model.type+"), not found device: " + this.model.monitoredDevices[i] + ", index: " + i);
                }
            }

            initChart.call(this);

        }else{

            try{

                loadData.call(this);

            }catch(e){console.error("Error initializing Chart: " +this.model.title + "("+this.model.type+")",e.stack);}

        }

    };

    this.onResize = function (force) {
        $(this.el).show();
        if(chart && (this.resizing || force) ){
            this.resizing = false;
            var $el = $(this.el);
            var $chart = $(".highcharts-container", $el);
            $chart.css("width", "100%");
            chart.reflow();
        }
    };

    this.onStartResize = function () {
        if(chart){
            $(this.el).hide(); // hide for performance reasons
        }
        this.resizing = true;
    };


    this.destroy = function () {
        if (chart){

            removeRealtimeListeners.call(this);

            try{chart.destroy();}catch (e){ console.error(e);} // FIX: avoid error if chart previos fail.
        }
        $(this.el).empty();
    };

    this.update = function (data) {

        var reloadDataset = this.super.update(data);

        if(chart && data.viewOptions && this.model.viewOptions){
            if(chart && data.viewOptions && data.viewOptions.max != this.model.viewOptions.max) reloadDataset = true;
        }

        // Clear previous errors
        this.model.error = false;
        this.model.errorMessage = null;

        if(reloadDataset){
            this.destroy();
            this.render(this.el);
        }else{
            if(!data.realtime) loadData.call(this);
        }

    };

    this.getChart = function(){
        return chart;
    }


    // ==========================================================================
    // Private
    // ==========================================================================

    function initChart(data) {

        // Create series
        var _this = this;
        var devices = this.model.monitoredDevices;
        var deviceSeries = [];
        var showLegends = false; // TODO: FROM CONFIG
        var viewOptions = this.model.viewOptions;
        this.initialized = true;



        // ===========================================================================
        // ERROR handler
        // ===========================================================================

        if (this.model.error) {
            $(this.el).html(this.model.errorMessage);
            return true;
        }

        // =============================================================================================

        if (this.model.type == 'LINE_CHART' || this.model.type == 'AREA_CHART') {

            for (var i = 0; i < devices.length; i++) {
                var device = OpenDevice.findDevice(devices[i]);

                var dserie = {
                    name: device.name,
                    showInLegend: showLegends
                };

                if(device.type == od.DeviceType.DIGITAL){
                    dserie.step = 'left'; // make chart ON/OFF style
                }

                if(this.model.realtime){
                    dserie.data = (function () {
                        // generate an array of random data
                        var data = [],
                            time = (new Date()).getTime(),
                            i;

                        for (i = -30; i <= 0; i += 1) {
                            data.push({
                                x: time + i * 1000,
                                y: 0
                            });
                        }
                        return data;
                    }());
                }else{
                    dserie.data = data[i]
                }

                deviceSeries.push(dserie);
            }

            // ===========================================================================
            // LINE_CHART for ANALOG
            // ===========================================================================

            var device = OpenDevice.findDevice(devices[0]);

            if(od.DeviceType.isAnalog(device.type)){

                // chart = $(this.el).highcharts({
                chart = $(this.el).highcharts({
                    chart: {
                        type: (this.model.type == 'LINE_CHART' ? 'spline' : 'areaspline'),
                        zoomType: 'xy',
                        panning : true,
                        panKey : 'shift',
                        margin: [ 10, 10, 25, 43],
                        resetZoomButton: {
                            position: {
                                x: 5,
                                y: -5
                            }
                        },
                        events: {
                            selection: function(event) {
                                if(event.xAxis != null) {
                                    console.log("ChartSelection: (min, max):", event.xAxis[0].min, event.xAxis[0].max);
                                }
                            }
                        }
                    },
                    title: {
                        text: '', style: {display: 'none'}
                    },
                    xAxis: {
                        type: 'datetime',
                        dateTimeLabelFormats: { // don't display the dummy year
                            second: '%H:%M:%S',
                            month: '%e. %b',
                            year: '%b'
                        },
                        title: {
                            text: '', style: {display: 'none'}
                        }
                    },
                    yAxis: {
                        title: {
                            text: null // Value title
                        },
                        min: (viewOptions && viewOptions.min ? viewOptions.min : 0),
                        max: (viewOptions && viewOptions.max ? viewOptions.max : null)
                    },

                    tooltip: {
                        headerFormat: '<b>{series.name}</b><br>',
                        pointFormat: '{point.x:%e. %b (%H:%M:%S)}: <b>{point.y}</b>'
                    },
                    credits: {
                        enabled: false
                    },

                    plotOptions: {
                        //  spline: { animation: false, enableMouseTracking: false, stickyTracking: true, shadow: false, dataLabels: { style: { textShadow: false } } },
                        series: {
                            animation: false,
                            stickyTracking: false,
                            states: { hover: false }
                        },
                        spline: {
                            marker: { enabled: false },
                        },
                        areaspline: {
                            marker: {enabled: false}
                        }
                    },

                    series: deviceSeries
                }).highcharts();

            }

            // ===========================================================================
            // LINE_CHART for DIGITAL
            // ===========================================================================

            if(device.type == od.DeviceType.DIGITAL){

                chart = $(this.el).highcharts({
                    chart: {
                        type: (this.model.type == 'LINE_CHART' ? 'line' : 'area'),
                        zoomType: 'x',
                        panning : true,
                        panKey : 'shift',
                        margin: [ 10, 10, 25, 43]
                    },
                    title: {
                        text: '', style: {display: 'none'}
                    },
                    xAxis: {
                        type: 'datetime',
                        dateTimeLabelFormats: { // don't display the dummy year
                            second: '%H:%M:%S',
                            month: '%e. %b',
                            year: '%b'
                        },
                        title: {
                            text: '', style: {display: 'none'}
                        }
                    },
                    yAxis: {
                        title: { text: null  }, // Value title
                        min : 0,
                        max : 1
                    },
                    tooltip: {
                        // valueSuffix: '°C'
                    },
                    credits: {
                        enabled: false
                    },
                    plotOptions: {
                        series: {
                            stickyTracking: false
                        },
                        line: {
                            marker: {enabled: false}
                        },
                        area: {
                            marker: {enabled: false}
                        }
                    },
                    series: deviceSeries
                }).highcharts();

            }

        }

        // ===========================================================================
        // GAUGE_CHART MODEL 1
        // ===========================================================================

        if (this.model.type == 'GAUGE_CHART' && this.model.viewOptions.subtype == "SOLID") {

            chart = $(this.el).highcharts({

                chart: {
                    type: 'solidgauge'
                },

                title: null,

                pane: {
                    center: ['50%', '95%'],
                    size: '150%',
                    startAngle: -90,
                    endAngle: 90,
                    background: {
                        backgroundColor: (Highcharts.theme && Highcharts.theme.background2) || '#EEE',
                        innerRadius: '60%',
                        outerRadius: '100%',
                        shape: 'arc'
                    }
                },

                tooltip: {
                    enabled: false
                },

                plotOptions: {
                    solidgauge: {
                        animation : false,
                        dataLabels: {
                            y: -22,
                            borderWidth: 0,
                            useHTML: true
                        }
                    }
                },
                yAxis: {
                    min: (viewOptions && viewOptions.min ? viewOptions.min : 0),
                    max: (viewOptions && viewOptions.max ? viewOptions.max : null),
                    title: {
                        y: -80
                    },
                    stops: [ // TODO: FROM CONFIG
                        [0.1, '#55BF3B'], // green
                        [0.5, '#DDDF0D'], // yellow
                        [0.9, '#DF5353']  // red
                    ],
                    lineWidth: 0,
                    minorTickInterval: null,
                    tickPixelInterval: 400,
                    tickWidth: 0,
                    labels: {y: 16}
                },

                credits: {enabled: false},

                series: [{
                    name: 'Value',
                    data: [getCurrentDeviceValue.call(_this)],
                    dataLabels: {
                        format: '<div style="text-align:center"><span style="font-size:22px;color:' +
                        ((Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black') + '">{y}</span><br/>'
                    },
                    tooltip: {
                        valueSuffix: ' N/A'
                    }
                }]

            }).highcharts();


        }

        // ===========================================================================
        // GAUGE_CHART MODEL 2
        // ===========================================================================

        if (this.model.type == 'GAUGE_CHART' && this.model.viewOptions.subtype == "NORMAL") {

            var config = {

                chart: {
                    type: 'gauge',
                    plotBackgroundColor: null,
                    plotBackgroundImage: null,
                    plotBorderWidth: 0,
                    plotShadow: false
                },

                title: null,
                credits: {enabled: false},

                pane: {
                    startAngle: -150,
                    endAngle: 150,

                    // Border effects
                    background: [{
                        backgroundColor: {
                            linearGradient: {x1: 0, y1: 0, x2: 0, y2: 1},
                            stops: [
                                [0, '#FFF'],
                                [1, '#333']
                            ]
                        },
                        borderWidth: 0,
                        outerRadius: '109%'
                    }, {
                        backgroundColor: {
                            linearGradient: {x1: 0, y1: 0, x2: 0, y2: 1},
                            stops: [
                                [0, '#333'],
                                [1, '#FFF']
                            ]
                        },
                        borderWidth: 1,
                        outerRadius: '107%'
                    }, {
                        // default background
                    }, {
                        backgroundColor: '#DDD',
                        borderWidth: 0,
                        outerRadius: '105%',
                        innerRadius: '103%'
                    }]
                },

                // the value axis
                yAxis: {
                    minorTickInterval: 'auto',
                    minorTickWidth: 1,
                    minorTickLength: 10,
                    minorTickPosition: 'inside',
                    minorTickColor: '#666',

                    tickPixelInterval: 30,
                    tickWidth: 2,
                    tickPosition: 'inside',
                    tickLength: 10,
                    tickColor: '#666',
                    labels: {
                        step: 2,
                        rotation: 'auto'
                    },
                    title: {
                        text: null
                    }
                },

                series: [{
                    name: this.model.title,
                    data: [getCurrentDeviceValue.call(_this)],
                    dataLabels : {
                        // borderRadius: 5,
                        //backgroundColor: "rgba(244,109,67, 0.7)",
                        borderWidth: 0,
                        //borderColor: "#F46D43",
                        style: {
                            fontSize: "25px"
                        },
                        // color: "#c2c2c2",
                        // crop: false,
                        // overflow: "none",
                        // formatter: function () {
                        //     return '<span style="font-size: 30px;">' + this.point.y + '</span>';
                        // },
                        // y: -65,
                        y: 30
                        // zIndex: 10
                    }
                }]
            };


            // Generate bands
            // =========================================
            var min =  (viewOptions && viewOptions.min ? parseInt(viewOptions.min) : 0);
            var max = (viewOptions && viewOptions.max ? parseInt(viewOptions.max) : 100);

            config.yAxis.min = min;
            config.yAxis.max = max;

            var stepDiff = Math.round((max - min) / 3);
            config.yAxis["plotBands"] = [];
            var colors = [ '#55BF3B', '#DDDF0D', '#DF5353']

            var step = min;
            for(var i = 0; i < 3; i++){
                config.yAxis["plotBands"].push({
                    from: step,
                    to: step+stepDiff,
                    color: colors[i]
                });
                step+=stepDiff;
            }

            config.yAxis["plotBands"][2].to = max; // fix max

            chart = $(this.el).highcharts(config).highcharts();

        }

        // ===========================================================================
        // PIE_CHART
        // ===========================================================================

        if (this.model.type == 'PIE_CHART') {

            // Build Series
            for (var i = 0; i < devices.length; i++) {
                var id = devices[i];
                var serie = {
                    name: OpenDevice.findDevice(id).name,
                    y : OpenDevice.findDevice(id).value
                };
                if(i == 0) {serie.sliced = true;serie.selected = true;};
                deviceSeries.push(serie);
            }

            // Build the chart
            chart = $(this.el).highcharts({
                chart: {
                    plotBackgroundColor: null,
                    plotBorderWidth: null,
                    plotShadow: false
                },
                title: null,
                credits: {enabled: false},
                tooltip: {
                    pointFormat: '<b>{point.y} ({point.percentage:.1f} %)</b>'
                },
                plotOptions: {
                    pie: {
                        allowPointSelect: true,
                        cursor: 'pointer',
                        dataLabels: {
                            enabled: true, // TODO configuration > pie-semi-circle
                            format: '<b>{point.name}</b>: {point.percentage:.1f} %',
                            style: {
                                color: (Highcharts.theme && Highcharts.theme.contrastTextColor) || 'black'
                            },
                            connectorColor: 'silver'
                        }
                        // todo: configuration > pie-semi-circle
                        //startAngle: -90,
                        //endAngle: 90,
                        //center: ['50%', '75%']
                    }
                },
                series: [{
                    type: 'pie',
                    //innerSize: '50%', // TODO configuration > pie-semi-circle
                    name: 'Browser share',
                    data: deviceSeries
                }]
            }).highcharts();

        }
    }

    function loadData() {

        this.data = [];

        var devices = this.model.monitoredDevices;

        for (var i = 0; i < devices.length; i++) {
            loadDataFor.call(this, devices[i], i);
        }

    }


    /**@see loadData */
    function loadDataFor(deviceID, index) {

        // console.log(this.title + ", Load: " + index);

        // Validade Device
        if(!ODev.get(deviceID)){
            this.model.error = true;
            this.model.errorMessage = "Device Not Found";
            initChart.call(this, this.data);
            return false;
        }


        var query = {
            'deviceID' : deviceID,
            'periodType': this.model.periodType,
            'periodValue': this.model.periodValue,
            'periodEnd': this.model.periodEnd,
            'aggregation': this.model.aggregation
        };

        var spinner = new Spinner().spin();
        $('.spinner',this.el).remove();
        $(this.el).append(spinner.el);

        var _this = this;

        OpenDevice.history(query, function (response) {

            var data = [];
            for (var i = 0; i < response.length; i++) {
                data.push([response[i].timestamp, response[i].value]);
            }

            console.log("Loaded Data ["+(_this.data.length+1)+"]: "+_this.title+", length: "+ data.length);

            spinner.stop();

            // For single value chart
            var value = 0;

            if(data.length > 0 && ( _this.model.aggregation && _this.model.aggregation != "NONE")){
                var value  = data[0][1];
                if(value % 1 != 0){
                    value = data[0][1].toFixed(2);
                    value = Number(value);
                }
            }

            // FIXME: this musb by dynamic (detection of initialization type)
            if(od.view.DashItemView.isCompatibleChart(_this.model.type)){

                // console.log(_this.title + ", Load: " + index + " [done]");
                _this.data.push(data);

                // all loaded
                if(_this.data.length == _this.model.monitoredDevices.length){
                    initChart.call(_this, _this.data);
                }

            }else{

                // FIXME: THIS IS FOR DYNAMIC VALUE (MOVED TO ANOTHER CLASS)
                $('.text-value',_this.el).text(value);

                $(_this.el).textfill({maxFontPixels : 65, explicitWidth : $(_this.el).width() - 20});
            }

        },function (jq,status,message) {
            _this.el.empty();
            var message = (jq.responseJSON.message || message);
            _this.el.append("<span class='itemview-error'>"+message+"</span>");
        });

    }

    function removeRealtimeListeners() {
        this.model.monitoredDevices.forEach(function(deviceID, index) {
            var device = ODev.get(deviceID);
            if(device){
                var list = realtimeListeners[index];
                console.log("Removing Listeners : " + deviceID);
                device.removeListener(list);
            }
        });
    }

    function getCurrentDeviceValue(){

        var deviceID = this.model.monitoredDevices[0];

        var device = ODev.get(deviceID);

        if(device){
            return device.value;
        }else{
            return -1;
        }

    }

    /**
     * This function is called when the device has changed (OpenDevice.onDeviceChange)
     * @param device
     */
    function updateRealtimeData(value, deviceID){

        var index = $.inArray(deviceID, this.model.monitoredDevices);

        if(index > -1){

            if(chart){

                if(this.model.type == "LINE_CHART"){
                    chart.series[index].addPoint([ (new Date()).getTime(), value], /*redraw=*/ true, /*shift=*/true, /*animation=*/true);
                }else if(this.model.type == "GAUGE_CHART"){
                    chart.series[index].points[0].update([0, value]);
                }else if(this.model.type == "PIE_CHART"){
                    chart.series[0].data[index].update(value);
                }

                // FIXME: this is for DYNAMIC TEXT
            }else{
                $('.text-value',this.el).text(value);

                $(this.el).textfill({maxFontPixels : 65, explicitWidth : $(this.el).width() - 20});
            }

        }

    }
});
/* ---------- *//*
 * ******************************************************************************
 *  Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 *  All rights reserved. This program and the accompanying materials
 *  are made available under the terms of the Eclipse Public License v1.0
 *  which accompanies this distribution, and is available at
 *  http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

// Register new Type
$.extend(od.view.dashTypes,{
    DIGITAL_CONTROLLER: {
        id: "DIGITAL_CONTROLLER", // Java Enum : DashboardType
        name: "Digital Controller",
        klass: "od.view.DigitalCtrlView",
        multipleDevices: true,
        allowSensor : false,
        allowDevice : true,
        deviceTypes: [od.DeviceType.DIGITAL],
        fields: [
            // [Name, Required, Default]
            // ["iconON", true, "lightbulb_on.png"],
            // ["iconOFF", true, "lightbulb_off.png"],
            ["textON", true, "ON"],
            ["textOFF", true, "OFF"],
        ]
    },
});

od.view.DigitalCtrlView = od.view.DashItemView.extend(function() {

    var _this = this;
    var deviceListeners = [];

    var HTML="";
    HTML += "<div class=\"device-view device-digital\">";
    HTML += "    <div class=\"device-view-icon\"><img src=\"/images/devices/lightbulb.png\"/><\/div>";
    HTML += "    <div class=\"device-view-content\">";
    HTML += "        <span class=\"device-view-title\">Device<\/span>";
    HTML += "        <span class=\"device-view-value\">OFF<\/span>";
    HTML += "    <\/div>";
    HTML += "<\/div>";

    this.render = function ($el) {

        this.el = $el;

        // create HTML

        var _this = this;

        this.model.monitoredDevices.forEach(function(deviceID){

            var device = ODev.get(deviceID);

            if(!device) console.error("Device with id: " + deviceID + " not found, chart: " + _this.model.title);

            if(device){

                var listener = device.onChange(onDeviceChange, _this);
                deviceListeners.push(listener);

                var $device = $(HTML);
                _this.el.append($device);
                $device.attr("data-deviceid", deviceID);
                $device.click(setValue);
                updateView.call(_this, $device, deviceID); // set values
            }
        });

    };

    this.destroy = function () {
        // Remove listeners from devices.
        this.model.monitoredDevices.forEach(function(deviceID, index) {
            var device = ODev.get(deviceID);
            if(device) device.removeListener(deviceListeners[index]);
        });

        this.super.destroy();
    }

    // ==========================================================================
    // Private
    // ==========================================================================

    function onDeviceChange(value, deviceID){
        var $device = $("[data-deviceid="+deviceID+"]", this.el);
        updateView.call(this, $device, deviceID); // use call(this, ) becouse is a OpenDevice inner event
    }

    function updateView($device, deviceID){
        var device = ODev.get(deviceID);
        $(".device-view-title", $device).text(device.title);

        var $value = $(".device-view-value", $device);
        $value.text(device.isON() ? this.model.viewOptions.textON : this.model.viewOptions.textOFF);

        $value.removeClass("on off");
        $value.addClass(device.isON() ? "on" : "off");

        var iconName = device.icon || "power.svg";
        var icon = device.isON() ? "on/" + iconName : "off/" + iconName;
        $("img", $device).attr('src', "/images/devices/" + icon);
    }

    function setValue(event){
        var deviceID = $(event.currentTarget).data("deviceid");
        OpenDevice.toggleValue(deviceID);
    }

});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

// Register new Type
$.extend(od.view.dashTypes,{

    IMAGE_CONTROLLER: {
        id: "IMAGE_CONTROLLER", // Java Enum : DashboardType
        name: "Video/Image",
        klass: "od.view.ImageCtrlView",
        multipleDevices: false,
        allowSensor : false,
        allowDevice : false,
        deviceTypes: [],
        fields: [
            // [Name, Required, Default]
            ["subtype", true, null],
            ["path", true, null]
        ]
    },
});

od.view.ImageCtrlView = od.view.DashItemView.extend(function() {

    var _this = this;

    var HTML_IMG="";
    HTML_IMG += "<div class=\"image-view\">";
    // HTML_IMG += "    <div class=\"corners\"><\/div>";
    HTML_IMG += "    <img border=\"0\" src=\"\" \/>";
    HTML_IMG += "<\/div>";

    this.render = function ($el) {

        this.el = $el;

        // create HTML
        if(this.model.viewOptions.subtype == "IMAGE"){
            var $html = $(HTML_IMG);
            $html.find("img").attr("src", this.model.viewOptions.path);
            _this.el.append($html);
        }
        if(this.model.subtype == "video"){
            // var $html = $(HTML_IMG);
            // $html.find("img").attr("src", this.model.path);
            // _this.el.append($html);
        }

    };

    this.destroy = function () {
        this.super.destroy();
    }

    // ==========================================================================
    // Private
    // ==========================================================================


});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

// Register new Type
$.extend(od.view.dashTypes,{
    DYNAMIC_VALUE: {
        id: "DYNAMIC_VALUE", // Java Enum : DashboardType
        name: "Dyn Value X",
        klass: "od.view.ValueView",
        multipleDevices: false,
        allowSensor : true,
        allowDevice : false,
        deviceTypes: [],
        fields: [
            // [Name, Required, Default]
            ["colors", false, null],
            ["thresholds", false, null]
        ]
    },
});

od.view.ValueView = od.view.DashItemView.extend(function() {

    var _this = this;

    var TEMPLATE="";
    TEMPLATE += "<div class=\"value-view\">";
    TEMPLATE += "    XXX";
    TEMPLATE += "<\/div>";

    this.render = function ($el) {

        this.el = $el;

        var $html = $(TEMPLATE);
        _this.el.append($html);

    };

    this.destroy = function () {
        this.super.destroy();
    }

    // ==========================================================================
    // Private
    // ==========================================================================


});

/* ---------- */
var Utils = {

    /**
     * Avoid multiple calls to function, filtering in specified threshold
     * Ref: https://remysharp.com/2010/07/21/throttling-function-calls
     */
    throttle: function(fn, threshhold, scope) {
        threshhold || (threshhold = 250);
        var last,
            deferTimer;
        return function () {
            var context = scope || this;

            var now = +new Date,
                args = arguments;
            if (last && now < last + threshhold) {
                // hold on to it
                clearTimeout(deferTimer);
                deferTimer = setTimeout(function () {
                    last = now;
                    fn.apply(context, args);
                }, threshhold);
            } else {
                last = now;
                fn.apply(context, args);
            }
        };
    },


    forDelayed: function(array, delay, fn) {

        var index = 0;
        function interation(index){
            if(index < array.length){
                setTimeout(function () {
                    fn.call(array, array[index], index);
                    interation(index+1);
                }, delay);
            }
        }

        interation(index);
    },

    isMobile: function() {
        var check = false;
        (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
        return check;
    },



    /**
     * Tigger HTML form Validation.
     * Used in Ajax forms.
     */
    validate : function($form) {

        $form.find('.form-invalid').removeClass("form-invalid"); // clear errors

        var valid = $form[0].checkValidity();

        if(!valid){
            var inputs = $form.find('input:invalid'); // find HTML Validation errors

            inputs.each(function() {
                $(this).addClass("form-invalid");
                $(this).one('blur', function(){
                    $(this).removeClass("form-invalid");
                });
            });

            inputs.first().focus();
        }

        return valid;
    },

    showSelectInvalid : function($form, modelName){
        var field = $form.find("[ng-model='"+modelName+"']");
        field.find('.ui-select-match').addClass('form-invalid');
        return false;
    }

};

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

// Requied to define "package" of modules.
angular.module('opendevice.controllers', []);

var AppConstants = {
    LocalStorage: {
        AUTH_TOKEN : "AuthToken",
        EXTENSIONS : "odev.extensions",
        DEVICE_CACHE : "odev_devices",
    }
};


// This applications will be instantiated in BootstrapApp.js
var App = function(){

    // Get dynamic extenions
    var odev_extensions = localStorage.getItem(AppConstants.LocalStorage.EXTENSIONS);
    if(odev_extensions != null){
        odev_extensions = JSON.parse(odev_extensions);
        odev_extensions = odev_extensions.map(function(item) {
            return "ext." + item['pathName'];
        });
    }

    var modules = [
        'ngRoute',
        'ngSanitize', // for: ui.select
        'ngAnimate',
        'ui.select',
        'gridster',
        //'opendevice.filters',
        //'opendevice.directives',
        'opendevice.services',
        'opendevice.controllers'
    ].concat(odev_extensions);

    var app = angular.module('opendevice', modules);

    // Constants
    // ===================
    // app.constant('opendevice_url', 'http://'+window.location.host);

    // Global variables
    app.run(function($rootScope) {

        OpenDevice.setAppID(OpenDevice.findAppID()); // find ApiKey in cookie/localstore
        if(!$rootScope.ext) $rootScope.ext = {}; // Extension support
        if(!$rootScope.ext.menu) $rootScope.ext.menu = [];

        ODev.connect();

        // Notification from Server
        ODev.on("ui_notification", function(message){
            $.notify(message.params, {type : message.params.type, delay : 3000});
        });

        // Avoid Expire session
        setInterval(function(){
            $.get("/api/auth/ping");
        }, 1000 * 60 * 15); //15min

        // If not logged go to login page
        if(!sessionStorage.getItem("logged") || sessionStorage.getItem("logged") == 'false'){
            window.location = "/login.html";
        }

        ODev.on("loginFail", function(){
            sessionStorage.setItem("logged", false);
            window.location = "/login.html?message=Not%20Logged%20or%20Expired";
        });

        $( document ).ajaxError(function( event, jqXHR, ajaxSettings, thrownError ) {
            //alert("error");
            //window.location = "/?message=Not%20Logged%20or%20Expired";
        });


        // Bootstrap Notify Config
        $.notifyDefaults({
            type: 'danger',
            allow_dismiss: true,
            delay: 3000
        });


        // Highcharts - Radialize the colors
        Highcharts.getOptions().colors = Highcharts.map(Highcharts.getOptions().colors, function (color) {
            return {
                radialGradient: { cx: 0.5, cy: 0.3, r: 0.7 },
                stops: [
                    [0, color],
                    [1, Highcharts.Color(color).brighten(-0.3).get('rgb')] // darken
                ]
            };
        });


        Highcharts.setOptions({
            global: {useUTC: false, colorSetup : true}
        });

    });

    app.config(['$routeProvider', function($routeProvider) {

        var odev_wait = {
            "check":function($q){
                var defer = $q.defer();

                defer.resolve(true); // disable wait connection
                // if(ODev.isConnected()){
                //     defer.resolve(true);
                // }else{
                //     ODev.onConnect(function(){
                //         defer.resolve(true);
                //     });
                // }
                return defer.promise; // route will wait the promise
            }
        };

        $routeProvider.when('/', {templateUrl: 'pages/dashboard.html', controller: 'DashboardController',  controllerAs: 'ctrl', resolve : odev_wait});
        $routeProvider.when('/boards', {templateUrl: 'pages/boards.html', controller: 'DeviceController',  controllerAs: 'ctrl', resolve : odev_wait});
        $routeProvider.when('/boards/:boardID', {templateUrl: 'pages/devices.html', controller: 'DeviceController',  controllerAs: 'ctrl', resolve : odev_wait});
        $routeProvider.when('/devices/:deviceID', {templateUrl: 'pages/device-view.html', controller: 'DeviceViewController',  controllerAs: 'ctrl', resolve : odev_wait});
        $routeProvider.when('/new', {templateUrl: 'pages/new.html', controller: 'DeviceController',  controllerAs: 'ctrl'});
        $routeProvider.when('/users', {templateUrl: 'pages/users.html', controller: 'UserController',  controllerAs: 'ctrl'});
        $routeProvider.when('/connections', {templateUrl: 'pages/connections.html', controller: 'ConnectionController',  controllerAs: 'ctrl'});
        $routeProvider.when('/firmwares', {templateUrl: 'pages/firmwares.html', controller: 'FirmwareController',  controllerAs: 'ctrl'});
        $routeProvider.when('/rules', {templateUrl: 'pages/rules.html', controller: 'RuleController',  controllerAs: 'ctrl'});
        $routeProvider.when('/rules/:id', {templateUrl: 'pages/subpages/new-rule.html', controller: 'RuleController',  controllerAs: 'ctrl', resolve : odev_wait});
        $routeProvider.when('/jobs', {templateUrl: 'pages/jobs.html', controller: 'JobController',  controllerAs: 'ctrl'});
        $routeProvider.when('/jobs/:id', {templateUrl: 'pages/subpages/new-job.html', controller: 'JobController',  controllerAs: 'ctrl', resolve : odev_wait});

        $routeProvider.otherwise({redirectTo: '/'});
    }]);

// Configuration to Work like JSP templates
    app.config(['$interpolateProvider', function($interpolateProvider) {
        $interpolateProvider.startSymbol('${');
        $interpolateProvider.endSymbol('}');
    }]);

    app.config(['$animateProvider', function($animateProvider) {
        $animateProvider.classNameFilter(/animate/);
    }]);

    app.filter('propsFilter', function() {
        return function(items, props) {
            var out = [];

            if (angular.isArray(items)) {
                items.forEach(function(item) {
                    var itemMatches = false;

                    var keys = Object.keys(props);
                    for (var i = 0; i < keys.length; i++) {
                        var prop = keys[i];
                        var text = props[prop].toLowerCase();
                        if (item[prop].toString().toLowerCase().indexOf(text) !== -1) {
                            itemMatches = true;
                            break;
                        }
                    }

                    if (itemMatches) {
                        out.push(item);
                    }
                });
            } else {
                // Let the output be the input untouched
                out = items;
            }

            return out;
        };
    });


    app.filter('deviceType', function() {
        return function(type) {
            for (var p in od.DeviceType) {
                if( od.DeviceType.hasOwnProperty(p) ) {
                    if(type == od.DeviceType[p]){
                        return p;
                    }
                }
            }
            return "Undefined";
        }
    });

    app.filter('deviceIcon', function() {
        return function(device) {

            if(!device) return "fa-cog";

            if(device.type == od.DeviceType.DIGITAL){
                return device.sensor ? "fa-plug" : "fa-lightbulb-o";
            }else if(device.type == od.DeviceType.ANALOG){
                return "fa-thermometer-quarter";
            }else if(device.type == od.DeviceType.NUMERIC){
                return "fa-bars";
            }else if(device.type == od.DeviceType.BOARD){
                return "fa-sitemap";
            }else{
                return "fa-cog";
            }

        }
    });

    app.filter('deviceRef', function() {
        return function(resourceID) {
            var device = ODev.findDevice(resourceID) || { description : "[Not Found]"};
            return device.description;

        }
    });

    app.filter('deviceNameRef', function() {
        return function(resourceID) {
            var device = ODev.findDevice(resourceID) || { name : "[Not Found]"};
            return device.name;

        }
    });



// After the AngularJS has been bootstrapped, you can no longer
// use the normal module methods (ex, app.controller) to add
// components to the dependency-injection container. Instead,
// you have to use the relevant providers. Since those are only
// available during the config() method at initialization time,
// we have to keep a reference to them.
// --
// NOTE: This general idea is based on excellent article by
// Ifeanyi Isitor: http://ify.io/lazy-loading-in-angularjs/
    var ex = {};
    app.config(
        function( $controllerProvider, $provide, $compileProvider ) {

            // $routeProvider

            // Provider-based controller.
            ex.controller = function( name, constructor ) {
                $controllerProvider.register( name, constructor );
                return( this );
            };

            ex.route = function() {
                debugger;
                $routeProvider.when(arguments);
                return( this );
            };

            // Provider-based service.
            ex.service = function( name, constructor ) {
                $provide.service( name, constructor );
                return( this );
            };
            // Provider-based factory.
            ex.factory = function( name, factory ) {
                $provide.factory( name, factory );
                return( this );
            };
            // Provider-based value.
            ex.value = function( name, value ) {
                $provide.value( name, value );
                return( this );
            };
            // Provider-based directive.
            ex.directive = function( name, factory ) {
                $compileProvider.directive( name, factory );
                return( this );
            };
            // NOTE: You can do the same thing with the "filter"
            // and the "$filterProvider"; but, I don't really use
            // custom filters.
        }
    );


// Service Worker for off-line capabilities
// SEE: https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/
    if ('serviceWorker-DISABLEDDDDDDDDDDDDDDDDDD' in navigator) {
        // Delay registration until after the page has loaded, to ensure that our
        // precaching requests don't degrade the first visit experience.
        // See https://developers.google.com/web/fundamentals/instant-and-offline/service-worker/registration
        window.addEventListener('load', function() {
            // Your service-worker.js *must* be located at the top-level directory relative to your site.
            // It won't be able to control pages unless it's located at the same level or higher than them.
            // *Don't* register service worker file in, e.g., a scripts/ sub-directory!
            // See https://github.com/slightlyoff/ServiceWorker/issues/468
            navigator.serviceWorker.register('service-worker.js').then(function(reg) {
                // updatefound is fired if service-worker.js changes.
                reg.onupdatefound = function() {
                    // The updatefound event implies that reg.installing is set; see
                    // https://w3c.github.io/ServiceWorker/#service-worker-registration-updatefound-event
                    var installingWorker = reg.installing;

                    installingWorker.onstatechange = function() {
                        switch (installingWorker.state) {
                            case 'installed':
                                if (navigator.serviceWorker.controller) {
                                    // At this point, the old content will have been purged and the fresh content will
                                    // have been added to the cache.
                                    // It's the perfect time to display a "New content is available; please refresh."
                                    // message in the page's interface.
                                    console.log('New or updated content is available.');
                                } else {
                                    // At this point, everything has been precached.
                                    // It's the perfect time to display a "Content is cached for offline use." message.
                                    console.log('Content is now available offline!');
                                }
                                break;

                            case 'redundant':
                                console.error('The installing service worker became redundant.');
                                break;
                        }
                    };
                };
            }).catch(function(e) {
                console.error('Error during service worker registration:', e);
            });
        });
    }

};

/* ---------- */var app = angular.module('opendevice.services', ['ngResource']);


// =====================================
// REST
// =====================================

app.factory('DashboardRest', ['$resource', function($resource){

    return $resource('/middleware/dashboards/:id', { id: '@id', dashID : '@dashID' }, { // configure defauls
        list: {method:'GET', url : "/middleware/dashboards", isArray:true,
            transformResponse: function(list){

                list = angular.fromJson(list);

                for (var i = 0; i < list.length; i++) {

                    var items = list[i].items;

                    for (var j = 0; j < items.length; j++) {
                        var item = items[j];

                        try {
                            if(typeof item.layout == "string") {
                                item.layout = JSON.parse(item.layout); // convert from String to Array
                            }
                        }catch (e){ item.layout = null;}

                        try {
                            if(typeof item.viewOptions == "string") {
                                item.viewOptions = JSON.parse(item.viewOptions); // convert from String to Array
                            }
                        }catch (e){ console.error('Error on viewOptions', e.stack); }

                        // if(!item.layout) item.layout = "[1,1,1,1]";

                    }

                }

                return list;
        }},
        activate: {method:'GET', url : "/middleware/dashboards/:id/activate"},
        items: {method:'GET', url : "/middleware/dashboards/:id/items", isArray:true},
        updateLayout: {method:'PUT', url : "/middleware/dashboards/:dashID/updateLayout",
            transformRequest: function(data) {
                var toSend = angular.copy(data);
                toSend.layout =  JSON.stringify(toSend.layout); // on server is a String
                if(toSend.viewOptions && toSend.viewOptions != "null")
                    toSend.viewOptions = JSON.stringify(toSend.viewOptions); // on server is a String
                return JSON.stringify(toSend);
            }
        },
        save: {method:'POST', url : "/middleware/dashboards"},
        saveItem: {method:'POST', url : "/middleware/dashboards/:dashID/item",
            transformRequest: function(data) {

                var toSend = angular.copy(data);

                if(toSend.layout && toSend.layout != "null")
                    toSend.layout =  JSON.stringify(toSend.layout); // on server is a String

                if(toSend.viewOptions && toSend.viewOptions != "null")
                    toSend.viewOptions = JSON.stringify(toSend.viewOptions); // on server is a String

                return JSON.stringify(toSend);
            },transformResponse: function(item, headersGetter){

                item = angular.fromJson(item);

                if(typeof item.viewOptions == "string" && item.viewOptions != "null") {
                    item.viewOptions = JSON.parse(item.viewOptions); // convert from String to Array
                }

                if(typeof item.layout == "string") {
                    item.layout = JSON.parse(item.layout); // convert from String to Array
                }

                return item;
            }
        },
        removeItem: {method:'DELETE', url : "/middleware/dashboards/:dashID/item"},
        deviceIcons: {method:'GET', url : "/middleware/dashboards/deviceIcons", isArray:true},
    });

}]);



app.factory('AccountRest', ['$resource', function($resource){

    var PATH = "/api/accounts";

    return $resource(PATH+'/:id', { id: '@id' }, { // configure defauls
        listUsers: {method:'GET', url : PATH+"/users", isArray:true},
        lisKeys: {method:'GET', url : PATH+"/keys", isArray:true},
        addUser: {method:'POST', url : PATH+"/users"},
        deleteUser: {method:'DELETE', url : PATH+"/users/:id"},
        loginAs: {method:'GET', url : PATH+"/loginAs/:id"}
    });

}]);

app.factory('ConnectionRest', ['$resource', function($resource){

    var PATH = "/middleware/connections/:id";

    return $resource(PATH, { id: '@id' }, { // configure defauls
        discovery: {method:'GET', url : PATH+"/discovery", isArray:true},
    });

}]);

app.factory('RuleRest', ['$resource', function($resource){

    var PATH = "/middleware/rules/:id";

    var resource = $resource(PATH, { id: '@id' }, {
        activate: {method:'PUT', url : PATH+"/activate"},
        update: {method:'PUT'},
    })

    resource.prototype.$saveOrUpdate = function(callback) {
        if (this.id) {
            return this.$update(callback);
        } else {
            return this.$save(callback);
        }
    };

    return resource;

}]);

app.factory('JobRest', ['$resource', function($resource){

    var PATH = "/middleware/jobs/:id";

    var resource = $resource(PATH, { id: '@id' }, {
        activate: {method:'PUT', url : PATH+"/activate"},
        update: {method:'PUT'},
    })

    resource.prototype.$saveOrUpdate = function(callback) {
        if (this.id) {
            return this.$update(callback);
        } else {
            return this.$save(callback);
        }
    };

    return resource;

}]);


app.factory('FirmwareRest', ['$resource', function($resource){

    var PATH = "/middleware/firmwares/:id";

    return $resource(PATH, { id: '@id' }, { // configure defauls
        sendUpdate: {method:'GET', url : PATH+"/sendUpdate", isArray:false},
    });

}]);


// =====================================
// Utils
// =====================================


/**
 * A generic confirmation for risky actions.
 * Usage: Add attributes: ng-really-message="Are you sure"? ng-really-click="takeAction()" function
 */
app.directive('ngReallyClick', [function() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            element.bind('click', function() {

                var $dialog = $('#confirm-dialog');
                var $button = $dialog.find("button:last");

                var message = attrs.ngReallyMessage;

                if(message) $dialog.find(".modal-title").text(message);
                else $dialog.find(".modal-title").text("Delete Parmanently");

                if(this.title) $button.text(this.title);
                else $button.text("OK");

                $dialog.modal('show');

                $button.one('click', function(){
                    scope.$apply(attrs.ngReallyClick);
                    $dialog.modal('hide');
                });

            });
        }
    }
}]);
/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */
// NOTE: Small/Simple controllers is here

var pkg = angular.module('opendevice.controllers');

pkg.controller('PageController', function ( $http, $scope) {

    // Alias / Imports
    var _this = this;
    var _public = this;

    // Public
    // ==========================

    // NProgress.configure({ minimum: 0.5 });
    //
    // $rootScope.$on('$routeChangeStart', function(next, current) {
    //     NProgress.start();
    // });
    //
    // $rootScope.$on('$routeChangeSuccess', function(next, current) {
    //     NProgress.done();
    // });


    $scope.$on("$routeChangeSuccess", function () {

        // Activate SideBar on Route Change
        var hrefs = window.location.hash; //html5: true
        angular.forEach($('ul.sidebar-menu a'), function (a) {
            a = angular.element(a);
            if (hrefs == a.attr('href')) {
                a.parent().addClass('active');
            } else {
                a.parent().removeClass('active');
            };
        });

        if(Utils.isMobile()){
            $('body').removeClass("sidebar-open");
        }


    });

    $scope.$on('$viewContentLoaded', function(){
        // Update title
        var $title = $("#page-title");
        $title.html("");
        $title.append($("span.page-title"));
    });

    $(function () {

        // First-Time Access
        if(!localStorage.getItem('SetupDevices')){
            localStorage.setItem('SetupDevices', 'true');
            window.location = "#/boards"
        }

        // Restore last page acessed, on session timeout Or if passed from external website.
        if(sessionStorage.getItem("LastPath")){
            window.location = sessionStorage.getItem("LastPath");
            sessionStorage.removeItem("LastPath");
        }

        // $('ul.sidebar-menu li').click( function() {
        //     $(this).addClass('active').siblings().removeClass('active');
        // });
    });


    _public.logout = function(){
        sessionStorage.setItem("logged", false);
        ODev.logout(function(){
            window.location = "/login.html?logout=true";
        });
    };

    /**
     * Replace Header ou another tag
     * @param target
     * @param el
     */
    _public.replace = function(target, el) {
        $(target).html("");
        $(target).append($(el));
    };

});/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * DashboardController for AngularJS
 *
 * Note: Access this controller from Chrome Debugger
 * angular.element(".content-wrapper").controller()
 * @author Ricardo JL Rufino
 * @date 06/07/14
 */
pkg.controller('DashboardController', ['$timeout', '$http', '$scope', 'DashboardRest', function ($timeout, $http, $scope, DashboardRest /*Service*/ ) {

    // Alias / Imports
    var DCategory = od.DeviceCategory;
    var DType = od.DeviceType;
    var DashItemView = od.view.DashItemView;

    // Private
    // ==========================

    var $dashboards; // @HtmlElement - $('.dashboards');
    var $layoutManager; // @Object - gridster instance
    var keydownListener;

    var _this = this;
    var _public = this;

    // Public
    // ==========================

    this.status = '';
    this.editMode = false;
    this.dashboard = null;
    this.dashboardItems = [ ]; // opendevice/DashItemView.js
    this.dashboardList = [];
    this.itemViewSelected = null;
    this.gridConf = {};
    this.odevListeners = []; // required because of our simple-page-model

    _public.init = function(){

        $(function(){

            $dashboards = $('.dashboards');

            var Key = {
                LEFT: 37,  UP: 38,  RIGHT: 39, DOWN: 40, F2 : 113, ESC : 27
            };

            $(document).on("keydown", keydownListener = function(event){

                if($(event.target).is(":input")){ // avoif affect fields,selects
                    return;
                }

                if(event.keyCode == Key.F2){
                    _this.toggleEdit();
                    $scope.$apply();
                }

                // F3
                if(event.keyCode == 114){
                    _this.addNewView();
                    $scope.$apply();
                    event.preventDefault();
                    event.stopPropagation(); // ignore browser search
                }

                // ESC
                if(event.keyCode == Key.ESC){
                    closeSidebar();

                    if(_this.editMode){
                        _this.toggleEdit(false);
                        $scope.$apply();
                    }

                }

                if (event.ctrlKey || event.metaKey) {
                    switch (String.fromCharCode(event.which).toLowerCase()) {
                        case 's':
                            event.preventDefault();
                            if(_this.editMode) _this.save();
                            break;
                        //case 'f':
                        //    event.preventDefault();
                        //    alert('ctrl-f');
                        //    break;
                        //case 'g':
                        //    event.preventDefault();
                        //    alert('ctrl-g');
                        //    break;
                    }
                }

                // Change chart using Keys
                if(event.keyCode > 48 && event.keyCode < 58){
                    var index = (event.keyCode - 48) - 1;
                    _this.activateDash(_this.dashboardList[index]);
                }

                // Plus (+)
                if (event.keyCode == 187 && _this.itemViewSelected != null) {
                    _this.updatePeriod(_this.itemViewSelected, true);
                }

                // Minus (-)
                if (event.keyCode == 189 && _this.itemViewSelected != null) {
                    _this.updatePeriod(_this.itemViewSelected, false);
                }

            });

            //$scope.$on('$viewContentLoaded', function(){
            //   // View loaded...
            //});

        });



        // Destroy Controller Event
        $scope.$on("$destroy", function() {
            for (var i = 0; i < _this.dashboardItems.length; i++) {
                var itemView = _this.dashboardItems[i];
                itemView.destroy();
            }

            // Unregister listeners on change page.
            ODev.removeListener(_this.odevListeners);

            closeSidebar();

            $(document).off("keydown", keydownListener);
        });

        configureLayoutManager();

        // // Load Dashboard's
        // // Wait for devices full loaded
        // _this.odevListeners.push(ODev.onConnect(function(){
        //     if(!_this.dashboardList.length) _this.syncDashboards();
        // }));

        _this.syncDashboards();

    };

    // ============================================================================================
    // Public Functions
    // ============================================================================================


    _public.updateSidebar = function(){
        // Configure sidebar
        var $side = $("aside.control-sidebar");
        var actions = $(".sidebar-content");
        $side.html(actions);
    }

    _public.activateDash = function(dashboard){

        if(!dashboard.active){

            // disable others
            for (var i = 0; i < _this.dashboardList.length; i++) {
                var current = _this.dashboardList[i];
                current.active = false;
            }

            dashboard.active = true;
            DashboardRest.activate({id : dashboard.id}); // save on database
        }

        _this.dashboard = dashboard;
        _this.itemViewSelected = null;

        var items = dashboard.items;

        // Remove Current
        // Clean LayoutManager
        if(_this.dashboardItems.length > 0){

            for (var i = 0; i < _this.dashboardItems.length; i++) {
                var itemView = _this.dashboardItems[i];
                itemView.destroy();
            }

            //$layoutManager.disable();
            //$layoutManager.remove_all_widgets();
            _this.dashboardItems = [];

        }

        // TODO: check if $timeout is required (for angular render)
        $timeout(function(){
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if(typeof item.layout == "string") {
                    item.layout = JSON.parse(item.layout); // convert from String to Array
                }
                var dashType = od.view.dashTypes[item.type];
                var klass = eval(dashType.klass); // get reference to implementation class
                _this.dashboardItems.push(new klass(item)); // fire 'onRenderDashboardItems'
            }
        });

        closeSidebar();

    };

    _public.syncDashboards = function() {
        // Load Dashboard's
        DashboardRest.list({}, function (values) {

            _this.dashboardList = values;

            angular.forEach(values, function (dashboard, index) {

                if (dashboard.active) {

                    _this.activateDash(dashboard);

                    return;
                }

            });

        });
    }

    _public.addNewDash = function(){
        $scope.$broadcast('newDash'); // fire 'open' in NewDashController
    };


    _public.addNewView = function(type){
        //_this.dashboardItems.push( new DashItemView({ configMode : true, title : 'Grafico 3 ', type : 'LINE_CHART', layout : [1,3,1,1], metrics : [{ deviceID : 2 , type : 'realtime'  }]}));
        // NOTE: this will fire: renderCompleteDashItem, to setup appropriate configs

        if(!type){

            var $side = $("aside.control-sidebar");

            $.AdminLTE.controlSidebar.open($side, true);

            $(".dashboards").one('click', function(){
                $.AdminLTE.controlSidebar.close($side, true);
            });

        }else{
            $scope.$broadcast('newItem', type);
        }

    };

    _public.insertNewItem = function(data){
        _this.toggleEdit(true);
        var dashType = od.view.dashTypes[data.type];
        var klass = eval(dashType.klass); // get reference to implementation class
        _this.dashboardItems.push(new klass(data)); // will trigger 'ng-repeat' and 'onRenderDashboardItems'

    };

    _public.notifyUpdateItem = function(model){
        var item = findDashboardItem(model.id);
        item.update(model);
    };

    _public.removeItem = function(index){

        console.log("removendo item:", index);
        var item = _this.dashboardItems[index];

        item.destroy();

        _this.dashboardItems.splice( index, 1 );

        DashboardRest.removeItem({id : item.id, dashID : this.dashboard.id});

    };

    _public.editItem = function(index){

        var item = _this.dashboardItems[index];

        $scope.$broadcast('editItem', {
            data: item.model
        });

    };



    /*
     * Change edit mode
     * This is called automatic, using watch
     */
    _public.toggleEdit = function(value){

        if(value == null){
            value = !_this.editMode;
        }

        _this.editMode = value;
        $layoutManager.resizable.enabled = value;
        $layoutManager.draggable.enabled = value;
    };


    /**
     * Save changes in active dashboard
     */
    _public.save = function(event){

        if(!_this.editMode) return;

        if(event){

            var inputs = $(event.target).serializeArray();
            var data = {};
            inputs.forEach(function (element) {
                data[element.name] = element.value;
            });

            // Update Local
            angular.extend(_this.dashboard, data);

            // Copy properties
            data = angular.extend({},_this.dashboard);

            delete data.items; // avoid serialize

            DashboardRest.save(data, function(resp){
                _this.editMode = false;
                $scope.$apply();
            });

        // CTRL + S  (Only save Layout)
        }else{
            _this.editMode = false;
            $scope.$apply();
        }

    };


    _public.delete = function(dasboard){

        if(!dasboard) dasboard = _this.dashboard;

        DashboardRest.delete({id : dasboard.id}, function(){
            _this.syncDashboards();
            _this.toggleEdit(false);
        });

    };


    /**
     * Set current Chart/View to use custom Keyboards
     * @param item
     */
    _public.setItemFocus = function(item){
        _public.itemViewSelected = item;
    };

    /**
     * Update chart/view period
     * Using 'throttle' to avoid multiple request at same time (on Keyboard)
     */
    _public.updatePeriod = Utils.throttle(function(index, add){
        var itemView = _this.dashboardItems[index];

        var periodValue =  (add ? itemView.model.periodValue + 1 : itemView.model.periodValue - 1);

        if(periodValue < 1) return;

        itemView.model.periodValue = periodValue;

        // required for REST Url.
        itemView.model.dashID = _this.dashboard.id;

        _this.notifyUpdateItem(itemView.model);
        _this.updatePeriodByGroup(itemView.model);

        // Save on server
        DashboardRest.saveItem(itemView.model, function(data){
            console.log('DashboardController::updatePeriod:', data);
        });
    }, 200);

    /**
     * Update Range/Period of same group.
     * If occur a period change in one item , all items of group are changed
     * @param model - Item Model
     */
    _public.updatePeriodByGroup = function(model){
        if(model.itemGroup > 0){
            var items = listItemsByGroup(model.itemGroup);
            for (var i = 0; i < items.length; i++) {
                var itemView = items[i];

                // Check if period changed
                if(model.periodValue != itemView.model.periodValue || model.periodType != itemView.model.periodType){
                    console.log('Updating item group: ' + model.itemGroup, itemView.model.title);
                    itemView.model.dashID = _this.dashboard.id;
                    itemView.model.periodValue = model.periodValue;
                    itemView.model.periodType = model.periodType;
                    itemView.update(itemView.model);
                    DashboardRest.saveItem(itemView.model); // save on database.
                }

            }
        }
    } ;

    /**
     * This method is called by angularjs (ngrepeat) when you add a new item to the list: 'dashboardItems'
     * @param container
     */
    _public.onRenderDashboardItems = function(scope) {

        // Wait angular render html to initialize charts.
        $timeout(function(){
            angular.forEach(_this.dashboardItems, function(item, index) {
                if(!item.initialized) {
                    console.log('Initializing Chart/View: ' + item.title, item);
                    var $el = $('.dash-body', $dashboards).eq(index);
                    item.render($el); // init
                }
            });
        },100);

    };

    _public.onGridInit = function(scope) {
        $layoutManager = scope.gridster;
    };

    _public.addItemListener = function ($gridScope, itemView) {

        $gridScope.$on('gridster-item-transition-end', function (event, source) {

            itemView.onResize();

        });
    };


    // ============================================================================================
    // Private Functions
    // ============================================================================================


    function findDashboardItem(id){
        var values = _this.dashboardItems;
        if(values){
            for(var i = 0; i < values.length; i++){
                if(values[i].id == id){
                    return values[i];
                }
            }
        } else{
            console.warn("Not loaded or empty !");
        }

        return null;
    }
    function listItemsByGroup(itemGroup){
        var values = _this.dashboardItems;
        var items = [];
        if(values){
            for(var i = 0; i < values.length; i++){
                if(values[i].model.itemGroup == itemGroup){
                    items.push(values[i]);
                }
            }
        } else{
            console.warn("Not loaded or empty !");
        }

        return items;
    }

    /**
     * Check views affected by grad-and-drop, resize
     * @returns {Array}
     */
    function gridDetectLayoutChanges(){

        var changes = [];

        angular.forEach(_this.dashboardItems, function(item, index) {
            var model = item.model;

            if(model.layout == null){
                model.layout = {};
                $.extend(model.layout, item.layout); // clone;
                changes.push(item);
                return;
            }

            if(item.layout.col != model.layout.col ||
                item.layout.row != model.layout.row ||
                item.layout.sizeX != model.layout.sizeX ||
                item.layout.sizeY != model.layout.sizeY){
                $.extend(model.layout, item.layout); // clone;
                changes.push(item);
            }
        });

        return changes;

    };

    /**
     * Dynamic grid system configuration
     * Builds upon the plugin: jquery.gridster
     */
    function configureLayoutManager(){
        _this.gridConf = {
            //margins: [5, 5],
            columns: 6,
            rowHeight : 100,
            avoid_overlapped_widgets : false,
            mobileBreakPoint: 600,
            resizable: {
                enabled: false,
                start: function (e, $ui, $element){
                    var dashView = _this.dashboardItems[$ui.data("index")];
                    dashView.onStartResize();
                },
                stop : function (e, $ui, $element){
                    var itensChanged = gridDetectLayoutChanges();

                    console.log("resize:: views changed:", itensChanged);

                    angular.forEach(itensChanged, function(item, index) {

                        item.model.dashID = _this.dashboard.id;

                        // Hack :: force update after animations (gridster-item-transition-end) see : addItemListener
                        $timeout(function(){
                            item.onResize(true); // force..
                        }, 500);

                        DashboardRest.updateLayout(item.model); // Save on database.
                    });
                }
            },
            draggable : {
                enabled: false,
                handle: '.dash-move',
                stop : function(){
                    var itensChanged = gridDetectLayoutChanges();
                    console.log("views changed:", itensChanged);

                    angular.forEach(itensChanged, function(item, index) {
                        item.model.dashID = _this.dashboard.id;
                        DashboardRest.updateLayout(item.model); // Save on database.
                    });
                }

            }
        };

        // Hack :: on gridster-resized (and window scrollbar shows), the layout change and affect charts
        // This will force charts resize
        $scope.$on("gridster-resized", function(){
            angular.forEach(_this.dashboardItems, function(item, index) {
                item.onResize(true);
            });
        });


        //var blockWidth = $dashboards.width();
        //blockWidth = (blockWidth / _this.gridConf.min_cols).toFixed() - 3;
        //_this.gridConf.widget_base_dimensions = [blockWidth, 150];

    }


    function closeSidebar(){
        var $side = $("aside.control-sidebar");
        $.AdminLTE.controlSidebar.close($side, true);
    }

}]);


// =========================================================================================================
// New Dashboard (Dialog in file dashboard.html)
// =========================================================================================================

pkg.controller('NewDashController', ['$scope','$timeout', 'DashboardRest', function ($scope, $timeout, DashboardRest) {

    // Private
    // ==========================
    var _this = this;
    var _public = this;
    var $el = $("#new-dash");

    var defaults = {
        title : ''
    };

    this.current = defaults;

    _public.init = function(){

        // Event received form DashboardController
        $scope.$on('editDash', function (scopeDetails, event) {
            _this.open(event.data);
            if(event.data.title) _this.current.titleVisible = true;
        });

        // Event received form DashboardController
        $scope.$on('newDash', function (scopeDetails, event) {
            _this.open(defaults);
        });

    };

    _public.open = function(data){

        console.log("Open Dialog", data);

        if(!data) data = defaults;

        _this.current = JSON.parse(JSON.stringify(data)); // clone

        $el.modal('show');

    };

    _public.save = function(event){

        var ctrl = $scope.$parent.ctrl;

        var isEdit = _this.current.id;

        var $btn = $el.find("button:submit");
        $btn.data("loading-text", "Saving...");
        $btn.button('loading');

        if(!isEdit) _this.current.active = true;

        // Save on server
        var req = DashboardRest.save(_this.current, function(data){
            console.log('NewDashController:: saved item: ', data);
            if($btn) $btn.button('reset');
            _this.current = defaults; // clear form
            if(!isEdit){
                ctrl.syncDashboards();
            }
            //else ctrl.notifyUpdateItem(data);
            $el.modal('hide');
        });

    };
}]);

// =========================================================================================================
// NewItemController / New Chart (Dialog in file dashboard.html)
// =========================================================================================================

pkg.controller('NewItemController', ['$scope','$timeout', 'DashboardRest', function ($scope, $timeout, DashboardRest) {

    // Private
    // ==========================
    var _this = this;
    var _public = this;
    var $el = $("#new-item-dialog");


    // Public
    // ==========================

    this.supportedTypes  = od.view.dashTypes;

    var defaults = {
        title : '',
        type : 'LINE_CHART',
        realtime : false,
        periodValue : 1,
        periodType : 'MINUTE',
        aggregation : "NONE",
        itemGroup : 0,
        titleVisible : true
    };

    this.current = defaults;

    this.deviceIcons = [];
    this.devices = [];

    // ====================================
    //  Public
    // ====================================

    _public.init = function(){

        // Event received form DashboardController.editItem
        $scope.$on('editItem', function (scopeDetails, event) {
            _this.open(event.data);
            if(event.data.title) _this.current.titleVisible = true;
        });

        // Event received form DashboardController
        $scope.$on('newItem', function (event, type) {
            var options = angular.copy(defaults);

            options.type = type;

            _this.open(options);
        });

        DashboardRest.deviceIcons(function(data){
            data.forEach(function(item){
                _this.deviceIcons.push({id:item, name: item });
            });
        });

    };

    _public.onSelectType = function(){

        setTypeDefaults(_this.current); //update

        var fields = getAllFields();
        if(fields) fields.each(function(){
            var $field = $(this);
            var name = $field.data("fname");
            if(isEnabled(name)){
                $field.show();
            }else{
                $field.hide();
            }
        });
    };


    // FIXME: Remove
    _public.enableAggregation = function(){
        return od.view.DashItemView.requireAggregation(_this.current.type) && ! _this.current.realtime;
    };

    // FIXME: Remove
    _public.enableRange = function(){
        return (_this.current.type == "LINE_CHART" || _this.current.type == "GAUGE_CHART") ;
    };

    _public.open = function(data){

        console.log("Open Dialog", data);

        _this.current = angular.copy(data);

        _this.devices = ODev.getDevices();

        _this.selectedType = {id : data.type}; // hack for select

        _this.onSelectType(); // show/hide fields

        var periodEnd = $el.find("input[name=periodEnd]");

        if(!periodEnd.data("range-enabled")){

            periodEnd.data("range-enabled", true);

            periodEnd.daterangepicker({
                "singleDatePicker": true,
                "timePicker": true,
                "timePicker24Hour": true,
                "linkedCalendars": false,
                "showCustomRangeLabel": false,
                "autoApply": true,
                "autoUpdateInput": false,
                locale: {
                    format: 'DD/MM/YY HH:mm'
                },
                "startDate": (_this.current.periodEnd || new Date())
            }, function(start, end, label) {
                console.log("New date range selected: ' + start.format('YYYY-MM-DD') + ' to ' + end.format('YYYY-MM-DD') + ' (predefined range: ' + label + ')");
            });

            periodEnd.on('apply.daterangepicker', function(ev, picker) {
                $(this).val(picker.startDate.format('DD/MM/YY HH:mm'));
                _this.current.periodEnd = picker.startDate.format('DD/MM/YY HH:mm');
            });

            periodEnd.on('cancel.daterangepicker', function(ev, picker) {
                if(_this.current.periodEnd){
                    $(this).val(_this.current.periodEnd);
                }
            });
        }else{
            if(_this.current.periodEnd) periodEnd.data('daterangepicker').setStartDate(_this.current.periodEnd);
        }


        $('#new-item-dialog').modal('show');

    };

    _public.save = function(dialog){

        var ctrl = $scope.$parent.ctrl;

        // required for REST Url.
        _this.current.dashID = ctrl.dashboard.id;

        var isEdit = _this.current.id;

        // _this.current.layout = null; // not update layout !

        var $btn = $el.find("button:submit");
        $btn.data("loading-text", "Saving...");
        $btn.button('loading');

        if(isEdit) ctrl.updatePeriodByGroup(_this.current);

        // Save on server
        var req = DashboardRest.saveItem(_this.current, function(data){
            console.log('NewItemController:: saved item: ', data);
            if($btn) $btn.button('reset');
            $el.modal('hide');
            if(!isEdit) ctrl.insertNewItem(data);
            else ctrl.notifyUpdateItem(data);
            _this.current = defaults;
        });

    };

    _public.selectGroupDevices = function (item){
        if (item.parent)
            return item.parent.title;
        else
            return "Standalone"
    };

    // ====================================
    //  Private
    // ====================================

    function getAllFields(){
        return $("[data-fname]",$el);
    }

    function setTypeDefaults(defaults){

        var dashType = od.view.dashTypes[defaults.type];

        if(!dashType) return defaults;

        var viewOptions = defaults.viewOptions || {};

        dashType.fields.forEach(function(field){
            if(field[2] && !viewOptions[field[0]] ){
                viewOptions[field[0]] = field[2];
            }
        });

        defaults.viewOptions = viewOptions;

        return defaults;
    }

    /**
     * Check if field is enabled/visible
     * @param name
     */
    function isEnabled(name){

        var dashType = od.view.dashTypes[_this.current.type];

        if(!dashType) return false;

        var enabled = false;

        dashType.fields.forEach(function(field){
            if(name == field[0]) enabled = true;
        });

        return enabled;
    }

}]);/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * Controller for Boards and Devices
 *
 * Note: Access this controller from Chrome Debugger
 * angular.element(".content-wrapper").controller()
 * @author Ricardo JL Rufino
 * @date 06/10/19
 */
pkg.controller('DeviceController', function ($scope, $routeParams, $timeout, $http, ConnectionRest) {

    // Alias / Imports
    var DCategory = od.DeviceCategory;
    var DType = od.DeviceType;
    var CType = od.CommandType;

    // Private
    // ==========================
    var _this = this;
    var _public = this;
    var odevListeners = []; // required because of our simple-page-model

    // Public
    // ==========================

    this.devices = [];
    this.discoveryList = [];

    this.historyCharts = []; // od.view.ChartItemView
    this.devicesCtrls = []; // od.view.DigitalCtrlView
    this.chartViewOptions = {
        "periodValue": 1,
        "periodType": "HOUR"
    };

    this.isBoardView = false;
    this.newBordPage = 'initialHelp';

    this.board;

    _public.init = function(){

        // Wait for devices full loaded
        if(!ODev.isConnected()){
            odevListeners.push(ODev.onConnect(function(){
                _this.init();
            }));
            // return; (allow off-line)
        }

        if($routeParams.boardID == "standalone"){ // Standalone Devices (DeviceList)

            this.isBoardView = true;

            this.board = { id : "standalone", name : "Standalone Devices", devices : { length : 0}};

        } else if($routeParams.boardID){ // Board Details (DeviceList)

            this.board = ODev.get($routeParams.boardID);

            this.isBoardView = true;

        } else { // Boards List Page

            this.isBoardView = false;

            this.board = null;

        }

        this.devices = filterLocalDevices.call(this);

        // Create Controllers and Charts for devices
        if(this.isBoardView){

            var charts = [];
            var ctrls = [];

            this.devices.forEach(function(device){

                var chart = createSensorChart.call(_this, device);
                if(chart) charts.push(chart);

                var ctrl = createDeviceControler.call(_this, device)
                if(ctrl) ctrls.push(ctrl);

            });

            _this.historyCharts = charts;
            _this.devicesCtrls = ctrls;
        }


        // Destroy Controller Event
        $scope.$on("$destroy", function() {

            for (var i = 0; i < _this.historyCharts.length; i++) {
                var view = _this.historyCharts[i];
                view.destroy();
            }
            for (var i = 0; i < _this.devicesCtrls.length; i++) {
                var view = _this.devicesCtrls[i];
                view.destroy();
            }

            // Unregister listeners on change page.
            ODev.removeListener(odevListeners);
        });

        // Watch for changes in Chart view options
        $scope.$watch('ctrl.chartViewOptions', function() {
            updateCharts.call(_this);
        }, true);


        // Defines a list where temporary listeners will be registered
        ODev.setListenerReceiver(odevListeners);

        // Fired by Sync or by Server
        ODev.on(od.Event.DEVICE_LIST_UPDATE, function(message){
            updateDevices();
        });

    };

    // ============================================================================================
    // Public Functions
    // ============================================================================================


    _public.newBoard = function(){

        $('#new-board').modal('show');

        _this.updateApiKeys();

        _this.newBordPage = 'initialHelp';

    };

    /** Dialog to list devices */
    _public.manageDevices = function(){

        $('#manageDevices').modal('show');

        _this.popupDevicesPage = 'list-devices';

    };

    _public.editDevice = function(device){
        $('#manageDevices').modal('hide');
        $("#manageDevices").on('hidden.bs.modal', function (e) {
            window.location = "#/devices/" + device.id;
        });


    };

    _public.delete = function(item, index){

        ODev.removeDevice(_this.devices[index]).then(function( data, textStatus, jqXHR ) {
            $.notify({message: "Removed"}, {type:"warning"});
        }).fail(function(req){
            if(req.responseJSON && req.responseJSON.message){
                $.notify({message: req.responseJSON.message});
            }
        });

    };

    _public.deleteHistory = function(item, index){

        ODev.deleteHitory(_this.devices[index]).then(function( data, textStatus, jqXHR ) {
            $.notify({message: "Removed"}, {type:"warning"});
        }).fail(function(req){
            if(req.responseJSON && req.responseJSON.message){
                $.notify({message: req.responseJSON.message});
            }
        });
    };


    _public.updateApiKeys = function(){
        // Show ApiKeys
        $.get("/api/accounts/keys", function(data){
            if(data && data instanceof Array){
                var $ul = $('#new-board .apiKeyList');
                $ul.empty();
                data.forEach(function(item){
                    var data = encodeURIComponent(location.host + "," + item.key);
                    $ul.append("<li>" + item.key + " ( " + location.host + " ) <br/>" +
                            "<img src='https://chart.googleapis.com/chart?cht=qr&chl="+data+"&chs=250x250' />" +
                            " </li>");
                });
            }
        });
    };

    _public.selectBoardConnection = function(type){

        _this.newBordPage = 'local';

        _this.startDiscovery(type);

    };

    _public.startDiscovery = function(type){

        if(!type) alert("Require type param");

        _this.discoveryList = ConnectionRest.discovery({type : type});

    };

    /**
     * Create a new Connection (for local devices)
     * @param connection
     */
    _public.boardConnect = function(info){

        ConnectionRest.save(info, function(){
            // $('#new-board').modal('hide');
            ODev.sync(true, true); // fire: DEVICE_LIST_UPDATE
            $.notify({message: "Saved"}, {type:"success"});
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });

    };

    /**
     * Start a tool to generate random data
     */
    _public.startSimulation = function(deviceID, interval, start){

        if(deviceID == null){

            $('#simulation').modal('show');

            _public.listSimulation();

        }else{

            $http.get("/tests/simulation/"+(start ? "start" : "stop")+"/"+deviceID+"?interval=" + interval).then(function(){

                if(start) _this.enableRealtime(deviceID, true);

                _public.listSimulation(); // update list

            }, function(response){ // error

                if(response.status == 503) {
                    alert("Maximum simulations reached. Stop simulations or increases in settings");
                }else{
                    console.error("Error starting simulation", response);
                    alert("Error starting simulation");
                }
            });
        }

    };

    _public.restoreSimulation = function(){
        $http.get("/tests/simulation/list").then(function(response){
            var devices = response.data;
            if(devices && devices instanceof Array){
                for(var i = 0; i < devices.length; i++){
                    _this.enableRealtime(devices[i].id, true);
                }
            }
        });
    };

    _public.listSimulation = function(){
        $http.get("/tests/simulation/list").then(function(response){
            var data = response.data;
            if(data && data instanceof Array){
                $scope["simulaionList"] = data;
            }
        });
    };

    _public.inSimulation = function(deviceID){
        var devices = $scope["simulaionList"];
        if(devices){
            var found = ODev.findDevice(deviceID, devices);
            return found != null;
        }else{
            return false;
        }
    };


    _public.send = function(data){

        //_this.devices = getDevices();
        _this.$apply();

    };

    /**
     * Function called by the View when a button is clicked
     */
    _public.toggleValue = function(id){
        OpenDevice.toggleValue(id);
    };

    /**
     * Send value to all devices.
     * @param value
     */
    _public.sendToAll = function(value){

        var devices =  OpenDevice.getDevices();
        for(var i = 0; i < devices.length; i++){
            if(!devices[i].sensor)
                devices[i].setValue(value);
        }

    };

    /** Force sync devices from physical module */
    _public.syncDevices = function(){
        OpenDevice.sync(true, true);
    };

    /** Get Icon for device */
    _public.getIcon = function(id){
        var device = findDevice(id);
        var cname = "";

        if(device.category == DCategory.GENERIC && !(device.sensor)){
            cname += "/images/devices/lightbulb_";
        }

        if(device.category == DCategory.LAMP){
            cname += "/images/devices/lightbulb_";
        }

        if(device.category == DCategory.POWER_SOURCE){
            cname += "/images/devices/battery_";
        }

        if(device.sensor){
            cname += "/images/devices/sensor_";
        }

        if(device.value == 1){
            cname += "on.png";
        }else{
            cname += "off.png";
        }

        return cname;
    };

    _public.isControllableDevice = function(device){

        if(device.type == od.DeviceType.DIGITAL) return true;

        return false;
    };

    _public.isAnalogDevice = function(device){

        if(device.type == od.DeviceType.ANALOG
            || device.type == od.DeviceType.FLOAT2
            || device.type == od.DeviceType.FLOAT4
            || device.type == od.DeviceType.FLOAT2_SIGNED) return true;

        return false;
    };

    _public.enableRealtime = function(deviceID, realtime){
        var item = findDashboardItem(deviceID);
        if(item){
            var model = angular.extend({}, item.model, { realtime : realtime});
            item.update(model);
        }
    };

    _public.showFullScreen = function(item){
        // var item = findDashboardItem(deviceID);
        if(item){
            $(item.el).toggleClass('chart-modal');
            item.getChart().reflow();

            $(document).one('keydown', function(e) {
                // ESCAPE key pressed
                if (e.keyCode == 27) {
                    $(item.el).toggleClass('chart-modal');
                    item.getChart().reflow();
                }
            });

        }
    };




    _public.setChartSize = function(kclass){

        var sizeClass = {
            "S" : "col-lg-4",
            "M" : "col-lg-6",
            "L" : "col-lg-12"
        };

        angular.forEach(_this.historyCharts, function(item, index) {

            var $container = $(".sensors-container");
            var $el = $('.sensors-view', $container).eq(index);

            item.onStartResize();

            var old = $el.data("sizeclass");
            if(old) $el.removeClass(old);

            $el.addClass(sizeClass[kclass]);
            $el.data("sizeclass", sizeClass[kclass]);

            setTimeout(function(){
                item.onResize(true);
            }, 400);

        });

    };

    _public.onRenderChartItems = function(scope){

        var $container = $(".sensors-container");

        // Wait angular render html to initialize charts.
        $timeout(function(){

            _public.setChartSize("S");

            // $("#char-size-ctrl button").last().button("toggle");

            angular.forEach(_this.historyCharts, function(item, index) {
                console.log('Initializing Chart/View: ' + item.title, item);
                if(!item.initialized) {
                    var $el = $('.sensor-chart-body', $container).eq(index);
                    item.render($el);
                }
            });
        });

        // Verify running simulations
        $timeout(function(){
           _this.restoreSimulation();
        }, 1000);

        return false;
    };

    _public.onRenderDeviceItems = function(scope){

        var $container = $(".devices-container");

        // Wait angular render html to initialize charts.
        $timeout(function(){

            angular.forEach(_this.devicesCtrls, function(item, index) {
                console.log('Initializing Device/View: ' + item.title, item);
                if(!item.initialized) {
                    var $el = $('.devices-view', $container).eq(index);
                    item.render($el);
                }
            });
        });

        return false;
    };

    // ============================================================================================
    // Private Functionsre
    // ============================================================================================

    function updateDevices(){

        var devices = filterLocalDevices.call(_this); // get devices for current view.

        var ctrls = [];

        // Destroy all
        for (var i = 0; i < _this.devicesCtrls.length; i++) {
            var view = _this.devicesCtrls[i];
            view.destroy();
        }

        // Recreate All
        devices.forEach(function(device){
            var ctrl = createDeviceControler.call(_this, device)
            if(ctrl) ctrls.push(ctrl);
        });

        $scope.$apply(function () {
            _this.devices = devices;
            _this.devicesCtrls = ctrls;
        });

    }

    function updateCharts(){
        angular.forEach(_this.historyCharts, function(item, index) {

            if(item.initialized && _this.chartViewOptions.periodType == "REALTIME") {
                _public.enableRealtime(item.model.monitoredDevices[0], true);
            }

            if(item.initialized && !item.model.realtime) {
                var model = angular.extend({}, item.model, _this.chartViewOptions);
                item.update(model);
            }
        });
    }


    function createSensorChart(device){

        if(device.type == od.DeviceType.DIGITAL || od.DeviceType.isAnalog(device.type)){

            var model = {
                "id": device.id,
                "title": device.title,
                "type": "LINE_CHART",
                // "layout": {"row": 0, "col": 2, "sizeX": 4, "sizeY": 2},
                "monitoredDevices": [device.id],
                "aggregation": "NONE",
                "itemGroup": 0,
                "realtime": false,
                "content": null,
                "scripts": null,
                "viewOptions": {}
            };

            angular.extend(model, this.chartViewOptions); // general options

            return new od.view.ChartItemView(model);
        }

        return null;
    }

    function createDeviceControler(device){

        // if(this.isControllableDevice(device)){

        if(device.type != od.DeviceType.BOARD){
            var model = {
                "type": "GENERIC_VIEW",
                "monitoredDevices": [device.id],
                "periodValue": 1,
                "realtime": true,
                "content": null,
                "scripts": null,
                "viewOptions": {
                   //  "icon": "power.svg",
                    "textON": "ON",
                    "textOFF": "OFF"
                }
            };

            return new GenericDeviceView(model);
        }else{

            return null;

        }


    }

    /**
     * Find device by ID
     * @param {Number} id
     * @returns {*}
     */
    function findDevice(deviceID){
        var devices = _this.devices;
        if(devices){
            for(var i = 0; i < devices.length; i++){
                if(devices[i].id == deviceID){
                    return devices[i];
                }
            }
        } else{
            console.warn("Devices not loaded or empty !");
        }

        return null;
    }


    /**
     * Filter the devices (ODev) corresponding to selected board
     * @returns {Array}
     */
    function filterLocalDevices(){

        var devices = [];

        if(this.board && this.board.id == "standalone"){ // Standalone Devices

            devices = ODev.getDevicesByBoard(0);

        } else if(this.board && this.board.id){ // Board Details (DeviceList)

            devices = ODev.getDevicesByBoard(this.board.id);

        } else { // Open Boards Page

            devices = ODev.getBoards();

            var standalone = ODev.getDevicesByBoard(0);

            // Add another devices in fake Board
            if(standalone && standalone.length > 0){

                var Board = { id : "standalone", name : "Standalone Devices", devices : { length : standalone.length}};

                devices.push(Board);
            }

        }

        return devices;
    }

    function findDashboardItem(id){
        var values = _this.historyCharts;
        if(values){
            for(var i = 0; i < values.length; i++){
                if(values[i].id == id){
                    return values[i];
                }
            }
        } else{
            console.warn("Not loaded or empty !");
        }

        return null;
    }


    // ===========================================================================================
    // GenericDeviceView
    // ===========================================================================================

    var GenericDeviceView = od.view.DashItemView.extend(function() {

        var _this = this;
        var deviceListeners = [];

        var HTML="";
        HTML += "<div class=\"device-view\">";
        HTML += "    <div class=\"device-view-icon\"><img src=\"/images/devices/lightbulb.png\"/><\/div>";
        HTML += "    <div class=\"device-view-content\">";
        HTML += "       <div class=\"dash-actions\">";
        HTML += "           <span title=\"Options\"><i class=\"fa fa-edit\"><\/i><\/span>";
        HTML += "       <\/div>";
        HTML += "       <span class=\"device-view-title\">Device<\/span>";
        HTML += "       <span class=\"device-view-value\">OFF<\/span>";
        HTML += "    <\/div>";
        HTML += "<\/div>";

        this.render = function ($el) {

            this.el = $el;

            // create HTML

            var _this = this;

            this.model.monitoredDevices.forEach(function(deviceID){

                var device = ODev.get(deviceID);

                if(!device) console.error("Device with id: " + deviceID + " not found, chart: " + _this.model.title);

                if(device){

                    var listener = device.onChange(onDeviceChange, _this);
                    deviceListeners.push(listener);

                    var $device = $(HTML);
                    _this.el.append($device);
                    $device.attr("data-deviceid", deviceID);
                    if(device.type == od.DeviceType.DIGITAL) $device.addClass("device-digital");
                    $device.click(setValue);
                    updateView.call(_this, $device, deviceID); // set values

                    var actions = $device.find(".dash-actions span");

                    actions.click(function(event){
                        event.stopPropagation();
                        var deviceID = $(event.currentTarget).parents('.device-view').data("deviceid");
                        window.location = "#/devices/" + deviceID;
                    });


                }
            });

        };

        this.destroy = function () {
            // Remove listeners from devices.
            this.model.monitoredDevices.forEach(function(deviceID, index) {
                var device = ODev.get(deviceID);
                if(device) device.removeListener(deviceListeners[index]);
            });

            this.super.destroy();
        }

        // ==========================================================================
        // Private
        // ==========================================================================

        function onDeviceChange(value, deviceID){
            var $device = $("[data-deviceid="+deviceID+"]", this.el);
            updateView.call(this, $device, deviceID); // use call(this, ) becouse is a OpenDevice inner event
        }

        function updateView($device, deviceID){
            var device = ODev.get(deviceID);
            $(".device-view-title", $device).text(device.title);

            var $value = $(".device-view-value", $device);

            var icon;
            if(device.type == od.DeviceType.DIGITAL){
                $value.text(device.isON() ? this.model.viewOptions.textON : this.model.viewOptions.textOFF);
                $value.removeClass("on off");
                $value.addClass(device.isON() ? "on" : "off");
                var iconName = device.icon || "power.svg";
                icon = device.isON() ? "on/" + iconName : "off/" + iconName;

            }else{
                var iconName = device.icon || "temp.svg";
                icon = "on/" + iconName;
                $value.text(device.value);
            }

            $("img", $device).attr('src', "/images/devices/" + icon);
        }

        function setValue(event){
            var deviceID = $(event.currentTarget).data("deviceid");
            OpenDevice.toggleValue(deviceID);
        }

    });
});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * Controller for Boards and Devices
 *
 * Note: Access this controller from Chrome Debugger
 * angular.element(".content-wrapper").controller()
 * @author Ricardo JL Rufino
 * @date 06/10/19
 */
pkg.controller('DeviceViewController', function ($scope, $routeParams, $timeout, $http, ConnectionRest, DashboardRest) {

    // Alias / Imports
    var DCategory = od.DeviceCategory;
    var DType = od.DeviceType;
    var CType = od.CommandType;

    // Private
    // ==========================
    var _this = this;
    var _public = this;
    var odevListeners = []; // required because of our simple-page-model

    // Public
    // ==========================
    this.device;
    this.board;
    this.pageNumber = 1;
    this.historyOptions = {
        periodType : 'RECORDS',
        periodValue : 100
    };

    this.history = [];
    this.deviceIcons = [];
    this.historyCharts = []; // od.view.ChartItemView
    this.chartViewOptions = {
        "periodValue": 1,
        "periodType": "HOUR"
    };

    _public.init = function(){

        // Wait for devices full loaded
        if(!ODev.isConnected()){
            odevListeners.push(ODev.onConnect(function(){
                _this.init();
            }));
            // return; (allow off-line)
        }

        this.device = ODev.get($routeParams.deviceID);
        this.board = ODev.get(this.device.parentID);

        _public.editDevice(this.device);

        DashboardRest.deviceIcons(function(data){
            data.forEach(function(item){
                _this.deviceIcons.push({id:item, name: item });
            });
        });


        loadHistory.call(this);

        // Destroy Controller Event
        $scope.$on("$destroy", function() {

            for (var i = 0; i < _this.historyCharts.length; i++) {
                var view = _this.historyCharts[i];
                view.destroy();
            }
            for (var i = 0; i < _this.devicesCtrls.length; i++) {
                var view = _this.devicesCtrls[i];
                view.destroy();
            }

            // Unregister listeners on change page.
            ODev.removeListener(odevListeners);
        });

        // // Watch for changes in Chart view options
        $scope.$watch('ctrl.historyOptions', function() {
            loadHistory.call(_this);
        }, true);


        // Defines a list where temporary listeners will be registered
        ODev.setListenerReceiver(odevListeners);



    };

    // ============================================================================================
    // Public Functions
    // ============================================================================================

    _public.editDevice = function(device){

        _this.formDevice = angular.copy(device);

        // Remove invalid attributes.
        delete _this.formDevice.listeners;
        delete _this.formDevice.manager;
        delete _this.formDevice.devices;
        delete _this.formDevice.parent;

    };

    _public.save = function(event){

        var $btn = $(event.target).find("button:submit");
        $btn.data("loading-text", "Saving...");
        $btn.button('loading');

        _this.formDevice.uid = _this.formDevice.id; // change to UID (the server property)

        ODev.save(_this.formDevice, function(state){
            if($btn) $btn.button('reset');
            if(state){
                $.notify({message: "Saved"}, {type:"success"});
            }else{
                $.notify({message: "Error on Save"}, {type:"error"});
            }
        });

    };

    _public.delete = function(item, index){

        ODev.removeDevice(_this.devices[index]).then(function( data, textStatus, jqXHR ) {
            $.notify({message: "Removed"}, {type:"warning"});
        }).fail(function(req){
            if(req.responseJSON && req.responseJSON.message){
                $.notify({message: req.responseJSON.message});
            }
        });

    };

    _public.deleteHistory = function(item, index){

        ODev.deleteHitory(_this.devices[index]).then(function( data, textStatus, jqXHR ) {
            $.notify({message: "Removed"}, {type:"warning"});
        }).fail(function(req){
            if(req.responseJSON && req.responseJSON.message){
                $.notify({message: req.responseJSON.message});
            }
        });
    };


    _public.getIcon = function(){
        if(this.formDevice.icon){
            return "images/devices/on/" + this.formDevice.icon;
        }else {
            return "images/boards/preview_board.svg";
        }
    };

    _public.nextPage = function(){
        if(_this.pageNumber > 1 && _this.history.length == 0) return;
        _this.pageNumber++;
        loadHistory.call(this);
    };

    _public.prevPage = function(){
        if(_this.pageNumber == 1) return;
        _this.pageNumber--;
        loadHistory.call(this);
    };

    // ============================================================================================
    // Private Functionsre
    // ============================================================================================

    function loadHistory(){

        if(_this.pageNumber <= 0) return;

        var query = {
            deviceID : _this.device.id,
            periodType : _this.historyOptions.periodType,
            periodValue : _this.historyOptions.periodValue,
            aggregation : 'NONE',
            order       : 'DESC',
            maxResults : 100,
            pageNumber : _this.pageNumber
        };

        var spinner = new Spinner().spin();
        $('.spinner',$("#device-history .box-header")).remove();
        $("#device-history .box-header").append(spinner.el);

        OpenDevice.history(query, function (data) {

            console.log("Loaded Data ["+(data.length)+"]: "+_this.device.description);

            spinner.stop();

            $scope.$apply(function () {
                _this.history = data;
            });

        },function (jq,status,message) {
            var message = (jq.responseJSON.message || message);
            console.error(message);
        });
    }


});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * Controller for Users/Accounts
 *
 * @author Ricardo JL Rufino
 * @date 16/10/16
 */
pkg.controller('UserController', function ($scope, AccountRest) {

    // Alias / Imports

    // Private
    // ==========================
    var _this = this;
    var _public = this;


    // Public
    // ==========================

    this.users = [];

    this.accounts = [];

    this.keys = [];

    $scope.model = {}; // curren editing

    _public.init = function(){

        _this.users = AccountRest.listUsers();

        _this.accounts = AccountRest.query();

        $(function(){

        });

    };

    // ============================================================================================
    // Public Functions
    // ============================================================================================


    _public.save = function(user, index){

        AccountRest.addUser(user, function(response){
            if(!user.id) _this.users.push(response);
            else _this.users[$scope.model.index] = response;

            $.notify({message: "Saved"}, {type:"success"});
            $scope.model = {};
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });

    };

    _public.editUser = function(user, index){

        $scope.model = angular.copy(user);
        $scope.model.index = index;
        $scope.editUser=true;

    };

    _public.deleteUser = function(user, index){
        AccountRest.deleteUser({id : user.id}, function() {
            _this.users.splice(index, 1);
            $.notify({message: "Removed"}, {type:"warning"});
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });
    };

    _public.delete = function(account, index){
        AccountRest.delete({id : account.id}, function() {
            _this.accounts.splice(index, 1);
            $.notify({message: "Removed"}, {type:"warning"});
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });
    };

    _public.loginAs = function(account, index){
        AccountRest.loginAs({id : account.id}, function(data) {

            // Clear private data
            for(var key in AppConstants.LocalStorage) {
                localStorage.removeItem(key);
            }

            localStorage.setItem(AppConstants.LocalStorage.AUTH_TOKEN, data.token);

            $.notify({message: "Reloading Page..."}, {type:"warning"});
            window.location.reload();
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });
    };

    _public.invitationLink = function(){

        $.get("/api/accounts/invitationLink", function(resp){

            var link = window.location.origin + "?invitation=" + resp.invitation;
            var html = "<textarea style='width: 100%'>"+link+"</textarea>";

            $.notify({message: html}, {type:"success", allow_dismiss : true, delay: 10000, placement: {
                from: "bottom",
                align: "right"
            }});
        });

    };


    _public.showApiKeys = function(){

        var keys = AccountRest.lisKeys();
        keys.$promise.then(function(list) {

            list.forEach(function(item){
                var data = encodeURIComponent(location.host + "," + item.key);
                item.qrcode = data;
            });

            _this.keys = keys;

        });



    };


    // ============================================================================================
    // Private Functionsre
    // ============================================================================================



});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * Controller for ConnectionController.js
 *
 * @author Ricardo JL Rufino
 * @date 16/10/16
 */
pkg.controller('ConnectionController', function ($scope,$route, ConnectionRest) {

    // Alias / Imports

    // Private
    // ==========================
    var _this = this;
    var _public = this;
    // var updateInterval;


    // Public
    // ==========================

    this.list = [];

    $scope.model = {}; // curren editing

    _public.init = function(){

        _this.update();

        // Destroy Controller Event
        $scope.$on("$destroy", function() {
            // $interval.cancel(updateInterval);
        });


        $scope.alertNew = localStorage.getItem($route.current.controller+'.alertNew') || true;
        if($scope.alertNew === "false") $scope.alertNew = false;

    };

    // ============================================================================================
    // Public Functions
    // ============================================================================================

    _public.edit = function(user, index){

        $scope.model = angular.copy(user);
        $scope.model.index = index;

    };

    _public.update = function(){

        _this.list = ConnectionRest.query();

    };

    _public.disconnect = function(uuid){

        ConnectionRest.delete({id : uuid}, function(){
            _this.update();
            $.notify({message: "Disconnected"}, {type:"success"});
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });

    };


    _public.disableAlert = function(name){
        localStorage.setItem($route.current.controller+'.'+name, 'false');
    };


    // ============================================================================================
    // Private Functionsre
    // ============================================================================================


});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * Controller for Actions
 *
 * @author Ricardo JL Rufino
 * @date 01/11/16
 */
pkg.controller('ActionController', function ($scope) {

    // Alias / Imports
    var DType = od.DeviceType;

    // Private
    // ==========================
    var _this = this;
    var _public = this;


    // Public
    // ==========================

    this.list = [];

    this.targetDevices = []; // for actions

    $scope.options = {
        actionTypes : [
            { code : "control", description : "Control other device(s)"},
            { code : "notification", description : "Notification"},
            { code : "webhook", description : "Webhook"},
            { code : "script", description : "Execute Script"}
        ]
    };

    _public.init = function(){

        _this.targetDevices = ODev.getDevices();

    };


    _public.groupDevices = function (item){
        if (item.parent)
            return item.parent.title;
        else
            return "Standalone"
    };

    // ============================================================================================
    // Private Functionsre
    // ============================================================================================

});
/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * Controller for Rules
 *
 * @author Ricardo JL Rufino
 * @date 01/11/16
 */
pkg.controller('RuleController', function ($scope, $location, $timeout, $routeParams, RuleRest) {

    // Alias / Imports
    var DType = od.DeviceType;

    // Private
    // ==========================
    var _this = this;
    var _public = this;

    var odevListeners = []; // required because of our simple-page-model

    // Public
    // ==========================

    this.list = [];

    this.devices = [];

    this.deviceTypes = [];

    this.deviceStates = [];


    $scope.options = {
        conditionTypes : [
            { code : "none", description : "Always"},
            { code : "activeTime", description : "Active Time"}
        ]
        ,evalConditionTypes : [
            { code : "EQUALS", description : " == "},
            { code : "DIFERNET", description : " != "}
        ]
        ,timeTypes : [
            { code : "SECOND", description : "Sec"},
            { code : "MINUTE", description : "Min"},
            { code : "HOUR", description : "Hours"}
        ]
    };


    $scope.model = new RuleRest(); // curren editing

    _public.init = function(){

        // PAGE: New / EDIT
        if($routeParams.id == "new" || $routeParams.id != null){

            _this.deviceTypes = ODev.getTypes();

            _this.deviceTypes.push({code:'all', description : "-- Show All--"});

            if($routeParams.id){
                $scope.model = RuleRest.get({id : $routeParams.id}, function(item){
                    var device = ODev.findDevice(item.resourceID);
                    if(device){
                        $scope.model.deviceType = device.type;
                        _public.filterDevices();
                    }
                });
            }

        // PAGE: LIST
        } else {

            _this.list = RuleRest.query();

            // Defines a list where temporary listeners will be registered
            ODev.setListenerReceiver(odevListeners);

            // Fired by Sync or by Server
            ODev.on("rules_update", function(message){
                $timeout(function(){
                    _this.list = RuleRest.query();
                }, 1000);
            });

        }

        // Destroy Controller Event
        $scope.$on("$destroy", function() {
            ODev.removeListener(odevListeners);
        });


    };

    // ============================================================================================
    // Public Functions
    // ============================================================================================


    _public.save = function(evt){

        var $form = $(evt.target);
        if(!Utils.validate($form)) return;

        if(!$scope.model.action){
            return Utils.showSelectInvalid($form, 'model.action.type');
        }

        if(!$scope.model.condition || $scope.model.condition.type == 'none') $scope.model.condition = null;

        $scope.model.$saveOrUpdate(function (response) {
            $.notify({message: "Saved"}, {type:"success"});
            $location.path('/rules');
        });

    };

    _public.delete = function(item, index){
        item.$delete(function(){
            _this.list.splice(index, 1);
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });
    };

    _public.activate = function(item){

        item.$activate(); // send updated value

    };

    _public.filterDevices = function(){

        var type = $scope.model.deviceType;

        if(type == 'all' || !type)  _this.devices = ODev.getDevices();
        else  _this.devices = ODev.getDevicesByType(type);

        if(type == DType.BOARD){
            _this.deviceStates = [
                { code : 1, description : "Up"},
                { code : 0, description : "Down"}
            ];
        }else{
            _this.deviceStates = [
                { code : -1, description : "Any Value"},
                { code : 1, description : "ON"},
                { code : 0, description : "OFF"},
                { code : "other", description : "Other"}
            ];
        }

    };


    _public.isShowCustomValue = function(){

        var device = ODev.findDevice($scope.model.resourceID);

        var type = $scope.model.deviceType;

        if(device){
            type = device.type;
        }

        if(od.DeviceType.DIGITAL == type){
            return false;
        }else{
            return true;
        }

    };


    // ============================================================================================
    // Private Functionsre
    // ============================================================================================



});

pkg.filter('conditionType', function() {
    return function(obj) {

        if(obj == null) return "None";

        if(obj.type == "activeTime") return "Ative for " + obj.time + " " + obj.intervalType +"s";

        obj = obj || '';

        return obj;
    };
});

pkg.filter('actionType', function() {
    return function(obj) {

        // Obj: {"type":"control","id":146552,"resourceID":213,"value":1}
        if(obj.type == "control"){
            var device = ODev.findDevice(obj.resourceID) || { name : "[Not Found Error]"};
            return "Control " + device.title;
        }

        obj = obj || '';

        return obj;
    };
});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

'use strict';

var pkg = angular.module('opendevice.controllers');

/**
 * Controller for Rules
 *
 * @author Ricardo JL Rufino
 * @date 01/11/16
 */
pkg.controller('JobController', function ($scope, $location, $timeout, $routeParams, JobRest) {

    // Private
    // ==========================
    var _this = this;
    var _public = this;

    var odevListeners = []; // required because of our simple-page-model

    // Public
    // ==========================

    this.list = [];

    $scope.model = new JobRest(); // curren editing

    _public.init = function(){

        if($routeParams.id == "new" || $routeParams.id != null){

            $scope.model.type = "cron"; // Default...

            if($routeParams.id != "new") {
                $scope.model = JobRest.get({id: $routeParams.id}, function (item) {
                    $('#cronInput').jqCronGetInstance().setCron(item.cronExpression);
                });
            }

            $('#cronInput').jqCron({
                enabled_minute: true,
                multiple_dom: true,
                multiple_month: true,
                multiple_mins: true,
                multiple_dow: true,
                multiple_time_hours: true,
                multiple_time_minutes: true,
                default_period: 'day',
                no_reset_button: false,
                lang: 'en',
                bind_method: {
                    set: function($element, value) {
                        $scope.model.cronExpression = value;
                        $element.val(value);
                    }
                }
            });

        } else { //  List Page

            _this.list = JobRest.query();

            // Defines a list where temporary listeners will be registered
            ODev.setListenerReceiver(odevListeners);

            // Fired by Sync or by Server
            ODev.on("jobs_update", function(message){
                $timeout(function(){
                    _this.list = JobRest.query();
                }, 1000);
            });


        }

        // Destroy Controller Event
        $scope.$on("$destroy", function() {
            ODev.removeListener(odevListeners);
        });


    };

    // ============================================================================================
    // Public Functions
    // ============================================================================================


    _public.save = function(evt){

        var $form = $(evt.target);
        if(!Utils.validate($form)) return;

        if(!$scope.model.action){
            return Utils.showSelectInvalid($form, 'model.action.type');
        }

        $scope.model.$saveOrUpdate(function (response) {
            $.notify({message: "Saved"}, {type:"success"});
            $location.path('/jobs');
        });

    };

    _public.delete = function(item, index){
        item.$delete(function(){
            _this.list.splice(index, 1);
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });
    };

    _public.activate = function(item){

        item.$activate(); // send updated value

    };

    _public.onRenderItems = function(){
        $timeout(function(){
            $('.cronspec').jqCron({
                disable : true,
                enabled_minute: true,
                multiple_dom: true,
                multiple_month: true,
                multiple_mins: true,
                multiple_dow: true,
                multiple_time_hours: true,
                multiple_time_minutes: true,});
        }, 200);
    };


    // ============================================================================================
    // Private Functionsre
    // ============================================================================================



});


pkg.filter('actionType', function() {
    return function(obj) {

        // Obj: {"type":"control","id":146552,"resourceID":213,"value":1}
        if(obj.type == "control"){
            var device = ODev.findDevice(obj.resourceID) || { title : "[Not Found Error]"};
            return "Control " + device.title;
        }else if(obj.type == "webhook"){
            return "Webhook " + obj.url.substring(0, 30) + "...";
        }

        return obj.type;
    };
});

/* ---------- *//*
 * *****************************************************************************
 * Copyright (c) 2013-2014 CriativaSoft (www.criativasoft.com.br)
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 *  Contributors:
 *  Ricardo JL Rufino - Initial API and Implementation
 * *****************************************************************************
 */

var pkg = angular.module('opendevice.controllers');

pkg.controller('FirmwareController', function ($timeout, $http, $scope, FirmwareRest, ConnectionRest) {

    var _this = this;
    var _public = this;

    $scope.model = new FirmwareRest(); // curren editing

    this.list = [];
    this.connections = [];

    this.selectedFirmware;

    _public.init = function(){

        _this.list = FirmwareRest.query();

    };


    _public.save = function(e){

        e.preventDefault();
        var formData = new FormData(e.target);

        $.ajax({
            url: "/middleware/firmwares",
            type: 'POST',
            data: formData,
            success: function (data) {
                _this.list = FirmwareRest.query();
                $.notify({message: "Saved"}, {type:"success"});
                $scope.$apply();
            },
            cache: false,
            contentType: false,
            processData: false
        });

    };

    _public.delete = function(item, index){
        item.$delete(function(){
            _this.list.splice(index, 1);
            $.notify({message: "Removed"}, {type:"success"});
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });
    };

    _public.showConnections = function(item){

        _public.selectedFirmware = item;
        // item.$activate(); // send updated value

        _this.connections = ConnectionRest.query();
        // returnList.$promise.then(function(list) {
        //     _this.connections = returnList;
        // });
    };

    _public.download = function(item){
        window.location = "/middleware/firmwares/download/" + item.uuid; // USE: FirmwareDownloadRest
    };

    _public.deploy = function(connectionUUID){

        _public.selectedFirmware.$sendUpdate({"connection" : connectionUUID},function(){
            $.notify({message: "Request Send"}, {type:"success"});
        }, function(error) {
            if(error.data && error.data.message){
                $.notify({message: error.data.message});
            }
        });


    };
});